[{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"setup-data","dir":"Articles","previous_headings":"","what":"Setup Data","title":"Areal Interpolation","text":"use North Carolina dataset sf package source, create generic grid target. Note: project data Albers Equal Area (EPSG:5070) accurate interpolation requires equal-area projection.","code":"library(duckspatial) library(sf)  # 1. Load Source Data (NC Counties) nc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE)  # 2. Transform to projected CRS (Albers) for accurate area calculations nc <- st_transform(nc, 5070)  # 3. Create a Target Grid grid <- st_make_grid(nc, n = c(10, 5)) |> st_as_sf()  # 4. Create Unique IDs (Required for interpolation) nc$source_id <- 1:nrow(nc) grid$target_id <- 1:nrow(grid)"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"extensive-vs--intensive-interpolation","dir":"Articles","previous_headings":"","what":"1) Extensive vs. Intensive Interpolation","title":"Areal Interpolation","text":"Areal interpolation works differently depending nature data.","code":""},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"case-a-extensive-variables-counts","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Case A: Extensive Variables (Counts)","title":"Areal Interpolation","text":"Variables like population counts total births (BIR74) spatially extensive. source polygon split half, count also split half. use weight = \"total\" ensure strict mass preservation relative source. Verification: total sum births result match original data (mass preservation).","code":"# Interpolate Total Births (Extensive) res_extensive <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   output = \"sf\" ) #> ✔ Query successful orig_sum <- sum(nc$BIR74) new_sum  <- sum(res_extensive$BIR74, na.rm = TRUE)  sprintf(\"Original: %s | Interpolated: %s\", orig_sum, round(new_sum, 1)) #> [1] \"Original: 329962 | Interpolated: 329962\""},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"case-b-intensive-variables-densitiesratios","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Case B: Intensive Variables (Densities/Ratios)","title":"Areal Interpolation","text":"Variables like population density infection rates spatially intensive. source polygon split, density remains pieces. duckspatial handles calculating area-weighted average.","code":"# Interpolate 'BIR74' treating it as an intensive variable (e.g. density assumption) res_intensive <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   intensive = \"BIR74\", # Treated as density here   weight = \"sum\",      # Standard behavior for intensive vars   output = \"sf\" ) #> ✔ Query successful"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"visual-comparison","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Visual Comparison","title":"Areal Interpolation","text":"Notice difference patterns. Extensive interpolation accumulates values based much “stuff” falls grid cell, intensive interpolation smoothes values based overlap.","code":"# Combine for plotting plot_data <- res_extensive[, \"BIR74\"] names(plot_data)[1] <- \"Extensive_Count\" plot_data$Intensive_Value <- res_intensive$BIR74  plot(plot_data[c(\"Extensive_Count\", \"Intensive_Value\")],       main = \"Interpolation Methods Comparison\",      border = \"grey90\",      key.pos = 4)"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"high-performance-output-as-tibble","dir":"Articles","previous_headings":"","what":"2) High Performance: Output as Tibble","title":"Areal Interpolation","text":"working massive datasets, constructing geometry result sf object can slow. need interpolated numbers, set output = \"tibble\". skips geometry construction step significantly faster.","code":"# Return a standard data.frame/tibble without geometry res_tbl <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   output = \"tibble\" ) #> ✔ Query successful  head(res_tbl) #> # A tibble: 6 × 3 #>   target_id crs_duckspatial BIR74 #>       <int> <chr>           <dbl> #> 1         1 EPSG:5070       1168. #> 2         2 EPSG:5070        379. #> 3         6 EPSG:5070        753. #> 4         7 EPSG:5070       5731. #> 5         8 EPSG:5070       8000. #> 6        11 EPSG:5070       1417."},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"database-mode-large-data-workflows","dir":"Articles","previous_headings":"","what":"3) Database Mode: Large Data Workflows","title":"Areal Interpolation","text":"datasets larger memory, persistent pipelines, can perform interpolation directly inside DuckDB database without pulling data R end. First, let’s establish connection load spatial layers tables. Now run interpolation referencing table names. can also use name argument save result directly new table instead returning R. can now query table read back later. wanted database table, without geometry, : preview table directly database:","code":"# Create connection conn <- ddbs_create_conn()  # Write layers to DuckDB ddbs_write_vector(conn, nc, \"nc_table\", overwrite = TRUE) #> ℹ Table <nc_table> dropped #> ✔ Table nc_table successfully imported ddbs_write_vector(conn, grid, \"grid_table\", overwrite = TRUE) #> ℹ Table <grid_table> dropped #> ✔ Table grid_table successfully imported # Run interpolation and save to new table 'nc_grid_births' ddbs_interpolate_aw(   conn = conn,   target = \"grid_table\",   source = \"nc_table\",   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   name = \"nc_grid_births\", # <--- Writes to DB   overwrite = TRUE ) #> ℹ Table <nc_grid_births> dropped #> ✔ Query successful  # Verify the table was created DBI::dbListTables(conn) #> [1] \"grid_table\"     \"nc_grid_births\" \"nc_table\" # Read the result back from the database final_sf <- ddbs_read_vector(conn, \"nc_grid_births\") #> ✔ table nc_grid_births successfully imported.  head(final_sf) #> Simple feature collection with 6 features and 2 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054293 ymin: 1348021 xmax: 1677656 ymax: 1484503 #> Projected CRS: NAD83 / Conus Albers #>   target_id     BIR74                              x #> 1         1 1168.3093 POLYGON ((1054293 1348021, ... #> 2         2  378.5281 POLYGON ((1132214 1348021, ... #> 3         6  752.9156 POLYGON ((1443895 1348021, ... #> 4         7 5731.0103 POLYGON ((1521815 1348021, ... #> 5         8 7999.6957 POLYGON ((1599735 1348021, ... #> 6        11 1416.5579 POLYGON ((1054293 1416262, ... ddbs_interpolate_aw(   conn = conn,   target = \"grid_table\",   source = \"nc_table\",   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   name = \"nc_grid_births\", # <--- Writes to DB   overwrite = TRUE,   output = \"tibble\" ) #> ℹ Table <nc_grid_births> dropped #> ✔ Query successful DBI::dbGetQuery(conn, \"SELECT * FROM nc_grid_births LIMIT 5\") #>   target_id crs_duckspatial     BIR74 #> 1         1       EPSG:5070 1168.3093 #> 2         2       EPSG:5070  378.5281 #> 3         6       EPSG:5070  752.9156 #> 4         7       EPSG:5070 5731.0103 #> 5         8       EPSG:5070 7999.6957"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"cleanup","dir":"Articles","previous_headings":"3) Database Mode: Large Data Workflows","what":"Cleanup","title":"Areal Interpolation","text":"Always close connection finished.","code":"duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"tldr","dir":"Articles","previous_headings":"","what":"TL;DR","title":"Benchmark","text":"{duckspatial} substantially faster uses way less memory {sf} pretty much cases, particularly working large data sets","code":""},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"prepare-data-for-benchmark","dir":"Articles","previous_headings":"","what":"Prepare data for benchmark","title":"Benchmark","text":"chunk code loads libraries create sample data sets used benchmark.","code":"library(duckspatial) library(bench) library(dplyr) library(sf) library(lwgeom) library(ggplot2) options(scipen = 999)  # read polygons data countries_sf <- sf::st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) #> Reading layer `countries' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/countries.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 257 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -178.9125 ymin: -89.9 xmax: 180 ymax: 83.65187 #> Geodetic CRS:  WGS 84  # generate random points set.seed(42)  ## create points data n = 10e4 points_sf_100k <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),       y = runif(n, min = -90, max = 90)     ) |>      sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  n = 10e5 points_sf_1mi <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),       y = runif(n, min = -90, max = 90)     ) |>      sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  # n = 10e6 # points_sf_10mi <- data.frame( #     id = 1:n, #     x = runif(n, min = -180, max = 180),   #     y = runif(n, min = -90, max = 90) #     ) |>  #     sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)"},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"spatial-join","dir":"Articles","previous_headings":"","what":"Spatial Join","title":"Benchmark","text":"example working 1 million points, {duckspatial} XX% faster used XX times less memory {sf}. bad.","code":"run_benchmark <- function(points_sf){          temp_bench <- bench::mark(         iterations = 1,          check = FALSE,          duckspatial = duckspatial::ddbs_join(             x = points_sf,              y = countries_sf,              join = \"within\"),                  sf = sf::st_join(             x = points_sf,              y = countries_sf,              join = sf::st_within)         )          temp_bench$n <- nrow(points_sf)     temp_bench$pkg <- c(\"duckspatial\", \"sf\")          return(temp_bench) }  # From 100K points to 1 million and 10 million points df_bench_join <- lapply(     X = list(points_sf_100k, points_sf_1mi),     FUN = run_benchmark     ) |>      dplyr::bind_rows()   # calculate difference in performance temp <- df_bench_join |>      filter(n == 10e5)  memo_diff <- round(as.numeric(temp$mem_alloc[2] / temp$mem_alloc[1]),1) time_diff <- (1 - round(as.numeric(temp$median[1] / temp$median[2]),2))*100 ggplot(data = df_bench_join) +     geom_point(size =3, aes(x= mem_alloc, y = median, color = pkg,                      shape = format(n, big.mark = \".\")                     )) +     labs(color= \"Package\", shape = \"Data size\",          y = \"Computation time (seconds)\",          x = \"Memory allocated\") +     theme_minimal()"},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"spatial-filter","dir":"Articles","previous_headings":"","what":"Spatial filter","title":"Benchmark","text":"example working 1 million points, {duckspatial} XX% faster used XX times less memory {sf}.","code":"run_benchmark <- function(points_sf){          temp_bench <- bench::mark(         iterations = 1,          check = FALSE,          duckspatial = duckspatial::ddbs_filter(             x = points_sf,              y = countries_sf),                  sf = sf::st_filter(             x = points_sf,              y = countries_sf)         )          temp_bench$n <- nrow(points_sf)     temp_bench$pkg <- c(\"duckspatial\", \"sf\")          return(temp_bench) }   # From 100K points to 1 million and 10 million points df_bench_filter <- lapply(     X = list(points_sf_100k, points_sf_1mi),     FUN = run_benchmark     ) |>      dplyr::bind_rows()   # calculate difference in performance temp <- df_bench_filter |>      filter(n == 10e5)  memo_diff <- round(as.numeric(temp$mem_alloc[2] / temp$mem_alloc[1]),1) time_diff <- (1 - round(as.numeric(temp$median[1] / temp$median[2]),2))*100 ggplot(data = df_bench_filter) +     geom_point(size =3, aes(x= mem_alloc, y = median, color = pkg,                      shape = format(n, big.mark = \".\")                     )) +     labs(color= \"Package\", shape = \"Data size\",          y = \"Computation time (seconds)\",          x = \"Memory allocated\") +     theme_minimal()"},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"spatial-distances","dir":"Articles","previous_headings":"","what":"Spatial distances","title":"Benchmark","text":"example calculating distance 10K points, {duckspatial} XX% faster, used XX times memory {sf}. Mind {sf} still efficient calculating Euclidean distances.","code":"# Turn on S2 (Spherical geometry) sf::sf_use_s2(TRUE)  run_benchmark <- function(n){          set.seed(42)      ## create points data     points_sf <- data.frame(         id = 1:n,         x = runif(n, min = -180, max = 180),           y = runif(n, min = -90, max = 90)         ) |>          sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)          temp_bench <- bench::mark(         iterations = 1,          check = FALSE,          duckspatial = duckspatial::ddbs_distance(             x = points_sf,              y = points_sf,              dist_type = \"haversine\"),                  sf = sf::st_distance(             x = points_sf,              y = points_sf,              which = \"Great Circle\")         )          temp_bench$n <- nrow(points_sf)     temp_bench$pkg <- c(\"duckspatial\", \"sf\")          return(temp_bench) }   # From 100K points to 1 million and 10 million points df_bench_distance <- lapply(     X = c(500, 1000, 10000),     FUN = run_benchmark     ) |>      dplyr::bind_rows()   # calculate difference in performance temp <- df_bench_distance |>      filter(n == 10000)  memo_diff <- round(as.numeric(temp$mem_alloc[1]) / as.numeric(temp$mem_alloc[2]) ,1) time_diff <- (1 - round(as.numeric(temp$median[1] / temp$median[2]),2))*100 ggplot(data = df_bench_distance) +     geom_point(size =3, aes(x= mem_alloc, y = median, color = pkg,                      shape = format(n, big.mark = \".\")                     )) +     labs(color= \"Package\", shape = \"Data size\",          y = \"Computation time (seconds)\",          x = \"Memory allocated\") +     theme_minimal()"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Intro to duckspatial","text":"can install {duckspatial} directly CRAN : can install development version GitHub :","code":"install.packages(\"duckspatial\") # install.packages(\"pak\") pak::pak(\"Cidree/duckspatial\")"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"core-idea-flexible-spatial-workflows","dir":"Articles","previous_headings":"","what":"Core idea: flexible spatial workflows","title":"Intro to duckspatial","text":"central design principle {duckspatial} spatial operation can used different ways, depending data stored want manage memory performance. functions {duckspatial} support four complementary workflows: Inputsf → Output sf Input sf → Output DuckDB table Input DuckDB table → Output sf Input DuckDB table → Output DuckDB table Let’s see examples illustrate workflows sample data sets.","code":"library(duckspatial) library(sf)  # polygons countries_sf  <- sf::st_read(     system.file(\"spatial/countries.geojson\",  package = \"duckspatial\"),     quiet = TRUE     )  # create random points set.seed(42) n <- 10000 points_sf <- data.frame(   id = 1:n,   x  = runif(n, min = -180, max = 180),   y  = runif(n, min =  -90, max =  90) ) |>   sf::st_as_sf(coords = c(\"x\",\"y\"), crs = 4326)"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"workflow-1-sf-input-sf-output","dir":"Articles","previous_headings":"Core idea: flexible spatial workflows","what":"Workflow 1: sf input → sf output","title":"Intro to duckspatial","text":"simplest way perform fast spatial operations. pass sf objects inputs, hood {duckspatial}: Registers temporarily DuckDB Executes spatial operation using SQL Returns result {sf} object example, use ddbs_join() (equivalent sf::st_join) determine country intersected point. use: quick analysis, prototyping, don’t need persist intermediate tables.","code":"result_sf <- ddbs_join(   x = points_sf,   y = countries_sf,   join = \"intersects\" )  head(result_sf) #> # A duckspatial lazy spatial table #> # ● CRS: EPSG:4326  #> # ● Geometry column: geometry  #> # ● Geometry type: POINT  #> # ● Bounding box: xmin: -72.756 ymin: -50.16 xmax: -67.795 ymax: -43.016  #> # Data backed by DuckDB (dbplyr lazy evaluation) #> # Use ddbs_collect() or st_as_sf() to materialize to sf #> # #> # Source:   SQL [?? x 9] #> # Database: DuckDB 1.4.3 [Cidre@Windows 10 x64:R 4.5.2/:memory:] #>      id CNTR_ID NAME_ENGL ISO3_CODE CNTR_NAME FID   date       geometry   #>   <int> <chr>   <chr>     <chr>     <chr>     <chr> <date>     <list>     #> 1   708 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> 2  3041 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> 3  9309 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> 4  2446 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> 5  8456 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> 6  2707 AR      Argentina ARG       Argentina AR    2021-01-01 <raw [32]> #> # ℹ 1 more variable: crs_duckspatial <chr>"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"creating-a-duckdb-connection","dir":"Articles","previous_headings":"Core idea: flexible spatial workflows","what":"Creating a DuckDB connection","title":"Intro to duckspatial","text":"next workflows use DuckDB connection, makes workflows much efficient working large spatial data sets general. create DuckDB connection, use ddbs_create_conn() function, automatically creates database connection installs / loads DuckDB’s spatial extension single call.","code":"# create duckdb con and install / load spatial extension conn <- duckspatial::ddbs_create_conn()"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"workflow-2-sf-input-duckdb-table","dir":"Articles","previous_headings":"Core idea: flexible spatial workflows","what":"Workflow 2: sf input → DuckDB table","title":"Intro to duckspatial","text":"workflow ideal start R, want persist results efficiently database without load results memory. pass sf objects input, {duckspatial} writes output directly DuckDB. difference also pass name table written output DuckDB database conn table saved. want fetch table memory, ddbs_read_vector() allows read table return sf object.","code":"ddbs_join(     conn = conn,     x = points_sf,     y = countries_sf,     join = \"intersects\",      name = \"points_in_countries_tbl\" ) tbl <- ddbs_read_vector(     conn = conn,     name = \"points_in_countries_tbl\"     )  head(tbl) #> Simple feature collection with 6 features and 7 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -72.75607 ymin: -50.15994 xmax: -67.79479 ymax: -43.01591 #> Geodetic CRS:  WGS 84 #>     id CNTR_ID NAME_ENGL ISO3_CODE CNTR_NAME FID       date #> 1  708      AR Argentina       ARG Argentina  AR 2021-01-01 #> 2 3041      AR Argentina       ARG Argentina  AR 2021-01-01 #> 3 9309      AR Argentina       ARG Argentina  AR 2021-01-01 #> 4 2446      AR Argentina       ARG Argentina  AR 2021-01-01 #> 5 8456      AR Argentina       ARG Argentina  AR 2021-01-01 #> 6 2707      AR Argentina       ARG Argentina  AR 2021-01-01 #>                      geometry #> 1 POINT (-72.75607 -50.15994) #> 2 POINT (-68.77194 -48.12303) #> 3 POINT (-70.82253 -46.23146) #> 4  POINT (-71.6444 -44.25323) #> 5 POINT (-71.18679 -44.60882) #> 6 POINT (-67.79479 -43.01591)"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"workflow-3-duckdb-tables-sf-output","dir":"Articles","previous_headings":"Core idea: flexible spatial workflows","what":"Workflow 3: DuckDB tables → sf output","title":"Intro to duckspatial","text":"workflow, spatial data lives inside DuckDB tables want return output sf objects memory. can easily write sf objects tables duckdb ddbs_write_vector() function passing sf data indicating name table written database. perform spatial operation, pass table names get sf object back. use: iterative workflows, larger--memory data, ’ll run multiple queries tables.","code":"# write `sf` objects as tables to duckdb duckspatial::ddbs_write_vector(     conn = conn,      data = countries_sf,      name = \"countries\"     )  duckspatial::ddbs_write_vector(     conn = conn,      data = points_sf,      name = \"points\"     ) result_sf <- ddbs_join(   conn = conn,   x = \"points\",   y = \"countries\",   join = \"intersects\"   )"},{"path":"https://cidree.github.io/duckspatial/articles/duckspatial.html","id":"workflow-4-duckdb-tables-duckdb-table","dir":"Articles","previous_headings":"Core idea: flexible spatial workflows","what":"Workflow 4: DuckDB tables → DuckDB table","title":"Intro to duckspatial","text":"fastest scalable workflow. entire computation happens inside DuckDB, result written new database table. use: large datasets, Production pipelines multiple steps results reused downstream DuckDB","code":"ddbs_join(   conn = conn,   x = \"points\",   y = \"countries\",   join = \"intersects\",    name = \"points_in_countries_tbl\",    overwrite = TRUE   )   # and read the table to memory as sf # tbl <- ddbs_read_vector( #     conn = conn, #     name = \"points_in_countries_tbl\" #     )"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"in-memory-pass-sf-return-sf","dir":"Articles","previous_headings":"","what":"1) In-memory: pass sf, return sf","title":"Spatial joins","text":"simplest way perform fast spatial join. simply pass two sf objects, ddbs_join() spins temporary DuckDB, runs join, returns sf. use: quick analysis, prototyping, don’t need persist intermediate tables.","code":"out_sf1 <- ddbs_join(   x    = points_sf,   y    = countries_sf,   join = \"within\" )  # quick peek # mapview(out_sf1, zcol=\"NAME_ENGL\")"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"connected-pass-table-names-in-duckdb-return-sf","dir":"Articles","previous_headings":"","what":"2) Connected: pass table names in DuckDB, return sf","title":"Spatial joins","text":"second third approaches, make use connection existing DuckDB database. let’s create fresh DuckDB connection using ddbs_create_conn() function, automatically install load DuckDB spatial extension connection. Now, second approach need first write layers DuckDB, perform spatial join referencing table names. Like : use: iterative workflows, larger--memory data, ’ll run multiple queries tables.","code":"# create a fresh DuckDB connection conn <- duckspatial::ddbs_create_conn() # write data to DuckDB ddbs_write_vector(conn, points_sf,   \"points\",    overwrite = TRUE) ddbs_write_vector(conn, countries_sf, \"countries\", overwrite = TRUE)  # spatial join inside DuckDB; result returned as sf out_sf2 <- ddbs_join(   conn,   x    = \"points\",   y    = \"countries\",   join = \"within\" )"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"write-to-db-create-a-new-table-with-the-join-result","dir":"Articles","previous_headings":"","what":"3) Write-to-DB: create a new table with the join result","title":"Spatial joins","text":"output approaches 1 2 sf object loaded memory. third approach, ddbs_join() writes new table DuckDB database. simply need name new table. use: iterative workflows, larger--memory data, ’ll run multiple queries tables.","code":"ddbs_join(     conn = conn,     x = \"points\",     y = \"countries\",     join = \"within\",     name = \"points_in_countries\",     overwrite = TRUE )  # use the result in SQL (or read back as sf later) # DBI::dbReadTable(conn, \"points_in_countries\") |> #     sf::st_as_sf(wkt = 'geometry') |>  #     head()"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"spatial-join-predicates","dir":"Articles","previous_headings":"","what":"Spatial Join Predicates:","title":"Spatial joins","text":"spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. join argument accepts spatial predicates: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching ’s boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x) Whether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"clean-up","dir":"Articles","previous_headings":"","what":"Clean up","title":"Spatial joins","text":"Don’t forget disconnect database.","code":"duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Adrián Cidre González. Author, maintainer. Rafael H. M. Pereira. Author. Egor Kotov. Author.","code":""},{"path":"https://cidree.github.io/duckspatial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cidre González , Pereira R, Kotov E (2026). duckspatial: R Interface 'DuckDB' Database Spatial Extension. R package version 0.9.0.9000, https://cidree.github.io/duckspatial/.","code":"@Manual{,   title = {duckspatial: R Interface to 'DuckDB' Database with Spatial Extension},   author = {Adrián {Cidre González} and Rafael H. M. Pereira and Egor Kotov},   year = {2026},   note = {R package version 0.9.0.9000},   url = {https://cidree.github.io/duckspatial/}, }"},{"path":"https://cidree.github.io/duckspatial/index.html","id":"duckspatial-","dir":"","previous_headings":"","what":"R Interface to DuckDB Database with Spatial Extension","title":"R Interface to DuckDB Database with Spatial Extension","text":"{duckspatial} package provides fast memory-efficient functions analyze manipulate large spatial vector datasets R. allows R users benefit directly analytical power DuckDB spatial extension, remaining fully compatible R’s spatial ecosystem, especially {sf}. core, {duckspatial} bridges two worlds: R spatial workflows based {sf} objects Database-backed spatial analytics powered DuckDB SQL design makes {duckspatial} especially well suited : Working large spatial data sets Speeding spatial analysis scale Workflows data fit comfortably memory Importantly, {duckspatial} brings power DuckDB spatial R users keeping workflows similar {sf} .","code":""},{"path":"https://cidree.github.io/duckspatial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Interface to DuckDB Database with Spatial Extension","text":"can install duckspatial directly CRAN : can install development version GitHub :","code":"install.packages(\"duckspatial\") # install.packages(\"pak\") pak::pak(\"Cidree/duckspatial\")"},{"path":"https://cidree.github.io/duckspatial/index.html","id":"core-idea-flexible-spatial-workflows","dir":"","previous_headings":"","what":"Core idea: flexible spatial workflows","title":"R Interface to DuckDB Database with Spatial Extension","text":"central design principle {duckspatial} spatial operation can used different ways, depending data stored want manage memory performance. functions {duckspatial} support four complementary workflows: Inputsf → Output sf Input sf → Output DuckDB table Input DuckDB table → Output sf Input DuckDB table → Output DuckDB table See “Get Started” vignette examples.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://cidree.github.io/duckspatial/reference/as_duckspatial_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert objects to duckspatial_df — as_duckspatial_df","title":"Convert objects to duckspatial_df — as_duckspatial_df","text":"Convert objects duckspatial_df","code":""},{"path":"https://cidree.github.io/duckspatial/reference/as_duckspatial_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert objects to duckspatial_df — as_duckspatial_df","text":"","code":"as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'duckspatial_df' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'sf' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'tbl_duckdb_connection' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'tbl_lazy' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'character' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)  # S3 method for class 'data.frame' as_duckspatial_df(x, conn = NULL, crs = NULL, geom_col = NULL, ...)"},{"path":"https://cidree.github.io/duckspatial/reference/as_duckspatial_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert objects to duckspatial_df — as_duckspatial_df","text":"x Object convert (sf, tbl_lazy, data.frame, table name) conn DuckDB connection (required character table names) crs CRS object string (auto-detected sf objects) geom_col Geometry column name (default: \"geom\") ... Additional arguments passed methods","code":""},{"path":"https://cidree.github.io/duckspatial/reference/as_duckspatial_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert objects to duckspatial_df — as_duckspatial_df","text":"duckspatial_df object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts from data frame to sf — convert_to_sf","title":"Converts from data frame to sf — convert_to_sf","text":"Converts table read DuckDB sf object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts from data frame to sf — convert_to_sf","text":"","code":"convert_to_sf(data, crs, crs_column, x_geom)"},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts from data frame to sf — convert_to_sf","text":"data tibble data frame crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. x_geom name geometry","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts from data frame to sf — convert_to_sf","text":"sf","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_wkb.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts from data frame to sf using WKB conversion — convert_to_sf_wkb","title":"Converts from data frame to sf using WKB conversion — convert_to_sf_wkb","text":"Converts table read DuckDB sf object.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_wkb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts from data frame to sf using WKB conversion — convert_to_sf_wkb","text":"","code":"convert_to_sf_wkb(data, crs, crs_column, x_geom)"},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_wkb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts from data frame to sf using WKB conversion — convert_to_sf_wkb","text":"data tibble data frame crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. x_geom name geometry column","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_wkb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts from data frame to sf using WKB conversion — convert_to_sf_wkb","text":"sf","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_wkb_to_sfc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert WKB data to sfc — convert_wkb_to_sfc","title":"Convert WKB data to sfc — convert_wkb_to_sfc","text":"Convert WKB data sfc","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_wkb_to_sfc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert WKB data to sfc — convert_wkb_to_sfc","text":"","code":"convert_wkb_to_sfc(geom_data, crs)"},{"path":"https://cidree.github.io/duckspatial/reference/crs_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two CRS objects for equality — crs_equal","title":"Compare two CRS objects for equality — crs_equal","text":"Properly compares CRS objects, handling different representations CRS.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/crs_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two CRS objects for equality — crs_equal","text":"","code":"crs_equal(crs1, crs2)"},{"path":"https://cidree.github.io/duckspatial/reference/crs_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two CRS objects for equality — crs_equal","text":"crs1 First CRS object crs2 Second CRS object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/crs_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two CRS objects for equality — crs_equal","text":"Logical indicating CRS equal","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a supported DuckDB connection — dbConnCheck","title":"Check if a supported DuckDB connection — dbConnCheck","text":"Check supported DuckDB connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a supported DuckDB connection — dbConnCheck","text":"","code":"dbConnCheck(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a supported DuckDB connection — dbConnCheck","text":"conn DBIConnection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a supported DuckDB connection — dbConnCheck","text":"TRUE (invisibly) successful import","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the area of geometries — ddbs_area","title":"Calculates the area of geometries — ddbs_area","text":"Calculates area geometries (\\(m^2\\)) DuckDB table sf object Returns result sf object area column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the area of geometries — ddbs_area","text":"","code":"ddbs_area(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the area of geometries — ddbs_area","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the area of geometries — ddbs_area","text":"new_column = NULL returns units vector \\(m^2\\). new_column NULL, output depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates the area of geometries — ddbs_area","text":"input geometry EPSG:4326, function uses ST_Area_Spheroid, use GeographicLib library calculating area using ellipsoidal model earth. method highly accurate calculating area line geometry considering curvature earth, also slowest. input geometry projected CRS, function use ST_Area calculate area squared meters. cases, function use ST_Area_Spheroid display warning.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculates the area of geometries — ddbs_area","text":"https://geographiclib.sourceforge.io/","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the area of geometries — ddbs_area","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") ) |>   ddbs_transform(\"EPSG:3857\")  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## calculate area (returns sf object with area column) ddbs_area(\"argentina\", conn)  ## calculate area with custom column name ddbs_area(\"argentina\", conn, new_column = \"area_sqm\")  ## create a new table with area calculations ddbs_area(\"argentina\", conn, name = \"argentina_with_area\", new_column = \"area_sqm\")  ## calculate area in a sf object ddbs_area(argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert geometries to standard interchange formats — ddbs_as_format","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"Convert spatial geometries common interchange formats using DuckDB spatial serialization functions. ddbs_as_text() – Convert geometries Well-Known Text (WKT) ddbs_as_wkb() – Convert geometries Well-Known Binary (WKB) ddbs_as_hexwkb() – Convert geometries hexadecimal Well-Known Binary (HEXWKB) ddbs_as_geojson() – Convert geometries GeoJSON","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"","code":"ddbs_as_text(x, conn = NULL, quiet = FALSE)  ddbs_as_wkb(x, conn = NULL, quiet = FALSE)  ddbs_as_hexwkb(x, conn = NULL, quiet = FALSE)  ddbs_as_geojson(x, conn = NULL, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"Depending function: ddbs_as_text() returns character vector WKT geometries ddbs_as_wkb() returns list raw vectors (binary WKB) ddbs_as_hexwkb() returns character vector HEXWKB strings ddbs_as_geojson() returns character vector GeoJSON strings","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"functions thin wrappers around DuckDB spatial serialization functions (ST_AsText, ST_AsWKB, ST_AsHEXWKB, ST_AsGeoJSON). useful exporting geometries widely supported formats interoperability external spatial tools, databases, web services.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert geometries to standard interchange formats — ddbs_as_format","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial)  argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\", package = \"duckspatial\") )  ddbs_as_text(argentina_ddbs) ddbs_as_wkb(argentina_ddbs) ddbs_as_hexwkb(argentina_ddbs) ddbs_as_geojson(argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_spatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a table with coordinates to spatial data — ddbs_as_spatial","title":"Convert a table with coordinates to spatial data — ddbs_as_spatial","text":"Converts data frame DuckDB table coordinate columns spatial points. function replicates functionality sf::st_as_sf() DuckDB spatial operations.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_spatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a table with coordinates to spatial data — ddbs_as_spatial","text":"","code":"ddbs_as_spatial(   x,   coords = c(\"lon\", \"lat\"),   crs = \"EPSG:4326\",   conn = NULL,   name = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_spatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a table with coordinates to spatial data — ddbs_as_spatial","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. coords Character vector length 2 specifying names longitude latitude columns (X Y coordinates). Defaults c(\"lon\", \"lat\"). crs Character numeric. Coordinate Reference System (CRS) input coordinates. Can specified EPSG code (e.g., \"EPSG:4326\" 4326) WKT string. Defaults \"EPSG:4326\" (WGS84 longitude/latitude). conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_spatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a table with coordinates to spatial data — ddbs_as_spatial","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_as_spatial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a table with coordinates to spatial data — ddbs_as_spatial","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  ## create sample data with coordinates cities_df <- data.frame(   city = c(\"Buenos Aires\", \"Córdoba\", \"Rosario\"),   lon = c(-58.3816, -64.1811, -60.6393),   lat = c(-34.6037, -31.4201, -32.9468),   population = c(3075000, 1391000, 1193605) )  # option 1: convert data frame to sf object cities_ddbs <- ddbs_as_spatial(cities_df)  # specify custom coordinate column names cities_df2 <- data.frame(   city = c(\"Mendoza\", \"Tucumán\"),   longitude = c(-68.8272, -65.2226),   latitude = c(-32.8895, -26.8241) )  ddbs_as_spatial(cities_df2, coords = c(\"longitude\", \"latitude\"))   ## option 2: convert table in duckdb to spatial table  # create a duckdb connection and write data conn <- duckspatial::ddbs_create_conn() DBI::dbWriteTable(conn, \"cities_tbl\", cities_df, overwrite = TRUE)  # convert to spatial table in database ddbs_as_spatial(     x = \"cities_tbl\",     conn = conn,     name = \"cities_spatial\",     overwrite = TRUE )  # read the spatial table ddbs_read_vector(conn, \"cities_spatial\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"Returns minimal bounding box enclosing input geometry sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"","code":"ddbs_bbox(   x,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. by_feature Boolean. function defaults FALSE, returns single bounding box x. TRUE, return one bounding box feature. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  # option 1: passing sf objects ddbs_bbox(argentina_ddbs)   ## option 2: passing the names of tables in a duckdb db  # creates a duckdb write sf to it conn <- duckspatial::ddbs_create_conn() ddbs_write_vector(conn, argentina_ddbs, \"argentina_tbl\", overwrite = TRUE)  output2 <- ddbs_bbox(     conn = conn,     x = \"argentina_tbl\",     name = \"argentina_bbox\" )  DBI::dbReadTable(conn, \"argentina_bbox\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the boundary of geometries — ddbs_boundary","title":"Returns the boundary of geometries — ddbs_boundary","text":"Returns boundary geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the boundary of geometries — ddbs_boundary","text":"","code":"ddbs_boundary(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the boundary of geometries — ddbs_boundary","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the boundary of geometries — ddbs_boundary","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the boundary of geometries — ddbs_boundary","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  # store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  # boundary b <- ddbs_boundary(x = \"argentina\", conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a buffer around geometries — ddbs_buffer","title":"Creates a buffer around geometries — ddbs_buffer","text":"Calculates buffer geometries DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a buffer around geometries — ddbs_buffer","text":"","code":"ddbs_buffer(   x,   distance,   num_triangles = 8L,   cap_style = \"CAP_ROUND\",   join_style = \"JOIN_ROUND\",   mitre_limit = 1,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a buffer around geometries — ddbs_buffer","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. distance numeric value specifying buffer distance. Units correspond coordinate system geometry (e.g. degrees meters) num_triangles integer representing many triangles produced approximate quarter circle. larger number, smoother resulting geometry. Default 8. cap_style character string specifying cap style. Must one \"CAP_ROUND\" (default), \"CAP_FLAT\", \"CAP_SQUARE\". Case-insensitive. join_style character string specifying join style. Must one \"JOIN_ROUND\" (default), \"JOIN_MITRE\", \"JOIN_BEVEL\". Case-insensitive. mitre_limit numeric value specifying mitre limit ratio. applies join_style \"JOIN_MITRE\". ratio distance corner mitre point corner radius. Default 1.0. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a buffer around geometries — ddbs_buffer","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a buffer around geometries — ddbs_buffer","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## basic buffer ddbs_buffer(conn = conn, \"argentina\", distance = 1)  ## buffer with custom parameters ddbs_buffer(conn = conn, \"argentina\", distance = 1,              num_triangles = 16, cap_style = \"CAP_SQUARE\")  ## buffer without using a connection ddbs_buffer(argentina_ddbs, distance = 1) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the centroid of geometries — ddbs_centroid","title":"Calculates the centroid of geometries — ddbs_centroid","text":"Calculates centroids geometries DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the centroid of geometries — ddbs_centroid","text":"","code":"ddbs_centroid(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the centroid of geometries — ddbs_centroid","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the centroid of geometries — ddbs_centroid","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the centroid of geometries — ddbs_centroid","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## centroid ddbs_centroid(\"argentina\", conn)  ## centroid without using a connection ddbs_centroid(argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_collect.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","title":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","text":"Materializes lazy duckspatial_df object executing underlying DuckDB query. Supports multiple output formats.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_collect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","text":"","code":"# S3 method for class 'duckspatial_df' collect(x, ..., as = NULL)  ddbs_collect(x, ..., as = c(\"sf\", \"tibble\", \"raw\", \"geoarrow\"))"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_collect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","text":"x duckspatial_df object ... Additional arguments passed collect Output format. One : \"sf\" (Default) Returns sf object sfc geometry \"tibble\" Returns tibble geometry column dropped (fastest) \"raw\" Returns tibble geometry raw WKB bytes \"geoarrow\" Returns tibble geometry geoarrow_vctr","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_collect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","text":"Collected data specified format Data specified format","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_collect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect a duckspatial_df with flexible output formats — collect.duckspatial_df","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial)  # Load lazy spatial data nc <- ddbs_open_dataset(system.file(\"shape/nc.shp\", package = \"sf\"))  # Perform lazy operations result <- nc |> dplyr::filter(AREA > 0.1)  # Collect to sf (default) result_sf <- ddbs_collect(result) plot(result_sf[\"AREA\"])  # Collect as tibble without geometry (fast) result_tbl <- ddbs_collect(result, as = \"tibble\")  # Collect with raw WKB bytes result_raw <- ddbs_collect(result, as = \"raw\")  # Collect as geoarrow for Arrow workflows result_ga <- ddbs_collect(result, as = \"geoarrow\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":null,"dir":"Reference","previous_headings":"","what":"Force computation of a lazy duckspatial_df — ddbs_compute","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"Executes accumulated query stores result DuckDB temporary table. result remains lazy (duckspatial_df) points materialized data, avoiding repeated computation complex query plans.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"","code":"ddbs_compute(x, ..., name = NULL, temporary = TRUE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"x duckspatial_df object ... Additional arguments passed dplyr::compute name Optional name result table. NULL, unique temporary name generated. temporary TRUE (default), creates temporary table automatically cleaned connection closes.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"new duckspatial_df pointing materialized table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"useful want : Cache intermediate results reuse across multiple subsequent operations Simplify complex query plans heavy operations like spatial joins Force execution specific point without pulling data R memory","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_compute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Force computation of a lazy duckspatial_df — ddbs_compute","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial) library(dplyr)  # Load lazy spatial data countries <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\", package = \"duckspatial\") )  # Complex pipeline - ddbs_compute() caches intermediate result cached <- countries |>   filter(CNTR_ID %in% c(\"DE\", \"FR\", \"IT\")) |>   ddbs_compute()  # Execute and store in temp table  # Check query plan - should reference temp table show_query(cached)  # Further operations continue from cached result result <- cached |>   ddbs_filter(other_layer, predicate = \"intersects\") |>   st_as_sf() } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"Returns concave hull enclosing geometry sf object DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"","code":"ddbs_concave_hull(   x,   ratio = 0.5,   allow_holes = TRUE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. ratio Numeric. ratio parameter dictates level concavity; 1 returns convex hull, 0 indicates return concave hull possible. Defaults 0.5. allow_holes Boolean. TRUE (default), allows output contain holes. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial) library(sf)  # create points data n <- 5 points_ddbs <- data.frame(   id = 1,   x = runif(n, min = -180, max = 180),   y = runif(n, min = -90, max = 90) ) |>   ddbs_as_spatial(coords = c(\"x\", \"y\"), crs = 4326) |>   ddbs_combine()  # option 1: passing ddbs or sf objects output1 <- duckspatial::ddbs_concave_hull(points_ddbs, output = \"sf\")  plot(output1)   # option 2: passing the name of a table in a duckdb db  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, points_ddbs, \"points_tbl\")  # spatial join output2 <- duckspatial::ddbs_concave_hull(  conn = conn,  x = \"points_tbl\",  output = \"sf\" )  plot(output2)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"Returns convex hull enclosing geometry sf object DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"","code":"ddbs_convex_hull(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  # option 1: passing sf objects output1 <- duckspatial::ddbs_convex_hull(x = argentina_ddbs, output = \"sf\")  plot(output1[\"CNTR_NAME\"])#' # store in duckdb  # option 2: passing the name of a table in a duckdb db  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina_tbl\")  # spatial join output2 <- duckspatial::ddbs_convex_hull(  conn = conn,  x = \"argentina_tbl\",  output = \"sf\" )  plot(output2[\"CNTR_NAME\"]) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a DuckDB connection with spatial extension — ddbs_create_conn","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"creates DuckDB connection, installs loads spatial extension","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"","code":"ddbs_create_conn(dbdir = \"memory\", threads = NULL, memory_limit_gb = NULL)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"dbdir String. Either \"tempdir\" \"memory\". Defaults \"memory\". threads Integer. Number threads use. NULL (default), setting changed, DuckDB engine use available cores detects (warning, shared HPC nodes detected number cores might total number cores node, per-job allocation). memory_limit_gb Numeric. Memory limit GB. NULL (default), setting changed, DuckDB engine use 80% available operating system memory detects (warning, shared HPC nodes detected memory might full node memory, per-job allocation).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"duckdb_connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # create a duckdb database in disk  (with spatial extension) conn <- ddbs_create_conn(dbdir = \"tempdir\")  # create a connection with 1 thread and 2GB memory limit conn <- ddbs_create_conn(threads = 1, memory_limit_gb = 2) ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and create schema — ddbs_create_schema","title":"Check and create schema — ddbs_create_schema","text":"Check create schema","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and create schema — ddbs_create_schema","text":"","code":"ddbs_create_schema(conn, name, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and create schema — ddbs_create_schema","text":"conn DBIConnection object DuckDB database name character string name schema created quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and create schema — ddbs_create_schema","text":"TRUE (invisibly) successful schema creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and create schema — ddbs_create_schema","text":"","code":"## load packages if (FALSE) { # \\dontrun{ library(duckspatial) library(duckdb)  ## connect to in memory database conn <- ddbs_create_conn(dbdir = \"memory\")  ## create a new schema ddbs_create_schema(conn, \"new_schema\")  ## check schemas dbGetQuery(conn, \"SELECT * FROM information_schema.schemata;\")  ## disconnect from db ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check CRS of spatial objects or database tables — ddbs_crs","title":"Check CRS of spatial objects or database tables — ddbs_crs","text":"S3 generic extracts CRS information various spatial objects.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check CRS of spatial objects or database tables — ddbs_crs","text":"","code":"ddbs_crs(x, ...)  # S3 method for class 'duckspatial_df' ddbs_crs(x, ...)  # S3 method for class 'sf' ddbs_crs(x, ...)  # S3 method for class 'tbl_duckdb_connection' ddbs_crs(x, ...)  # S3 method for class 'character' ddbs_crs(x, conn, crs_column = \"crs_duckspatial\", ...)  # S3 method for class 'duckdb_connection' ddbs_crs(x, name, ...)  # Default S3 method ddbs_crs(x, ...)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check CRS of spatial objects or database tables — ddbs_crs","text":"x object containing spatial data. Can : duckspatial_df: Lazy spatial data frame (CRS attributes) sf: sf object (CRS sf metadata) character: Name table database (requires conn) ... Additional arguments passed methods conn DuckDB connection (required character method) crs_column Column name storing CRS info (default: \"crs_duckspatial\") name Table name (backward compatibility first arg connection)","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check CRS of spatial objects or database tables — ddbs_crs","text":"CRS object sf package","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check CRS of spatial objects or database tables — ddbs_crs","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckdb) library(duckspatial) library(sf)  # Method 1: duckspatial_df objects nc <- ddbs_open_dataset(system.file(\"shape/nc.shp\", package = \"sf\")) ddbs_crs(nc)  # Method 2: sf objects nc_sf <- st_read(system.file(\"shape/nc.shp\", package = \"sf\")) ddbs_crs(nc_sf)  # Method 3: table name in database conn <- ddbs_create_conn(dbdir = \"memory\") ddbs_write_vector(conn, nc_sf, \"nc_table\") ddbs_crs(conn, \"nc_table\") ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_default_conn.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or create default DuckDB connection with spatial extension installed and loaded — ddbs_default_conn","title":"Get or create default DuckDB connection with spatial extension installed and loaded — ddbs_default_conn","text":"Get create default DuckDB connection spatial extension installed loaded","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_default_conn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or create default DuckDB connection with spatial extension installed and loaded — ddbs_default_conn","text":"","code":"ddbs_default_conn(create = TRUE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_default_conn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or create default DuckDB connection with spatial extension installed and loaded — ddbs_default_conn","text":"create Logical. TRUE connection exists, create one. Default TRUE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_default_conn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or create default DuckDB connection with spatial extension installed and loaded — ddbs_default_conn","text":"duckdb_connection NULL connection exists create = FALSE","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the difference of two geometries — ddbs_difference","title":"Calculates the difference of two geometries — ddbs_difference","text":"Calculates geometric difference two geometries, returns sf object creates new table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the difference of two geometries — ddbs_difference","text":"","code":"ddbs_difference(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the difference of two geometries — ddbs_difference","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the difference of two geometries — ddbs_difference","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the difference of two geometries — ddbs_difference","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\") ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## difference with a connection ddbs_difference(\"countries\", \"argentina\", conn)  ## difference without a connection ddbs_difference(countries_ddbs, argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the distance between two geometries — ddbs_distance","title":"Returns the distance between two geometries — ddbs_distance","text":"Returns distance two geometries units matrix. function automatically use best distance input Coordinates Reference System geometry type.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the distance between two geometries — ddbs_distance","text":"","code":"ddbs_distance(   x,   y,   dist_type = NULL,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the distance between two geometries — ddbs_distance","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn dist_type Character. Distance type calculated. default uses best option input CRS (see details). conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the distance between two geometries — ddbs_distance","text":"units matrix meters","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the distance between two geometries — ddbs_distance","text":"dist_type argument can take following values: NULL (default): use best option inputs CRS \"planar\": planar distance two geometries (default projected CRS) \"geos\": planar distance two geometries using GEOS library \"haversine\": returns great circle distance. Requires input WGS84 (EPSG:4326) POINT geometry (default EPSG:4326). \"spheroid\": returns distance using ellipsoidal model earth's surface using GeographicLib library. highly accurate slowest Note geometries different POINT supported \"haversine\" \"spheroid\".","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the distance between two geometries — ddbs_distance","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial)  # create points data n <- 10 points_sf <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90) ) |>     ddbs_as_spatial(coords = c(\"x\", \"y\"), crs = \"EPSG:4326\")  # option 1: passing sf objects output1 <- duckspatial::ddbs_distance(     x = points_sf,     y = points_sf,     dist_type = \"haversine\" )  head(output1)   ## option 2: passing the names of tables in a duckdb db and output as sf  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, points_sf, \"points\", overwrite = TRUE)  output2 <- ddbs_distance(     conn = conn,     x = \"points\",     y = \"points\",     dist_type = \"haversine\" ) head(output2)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list of GDAL drivers and file formats — ddbs_drivers","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"Get list GDAL drivers file formats","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"","code":"ddbs_drivers(conn = NULL)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"conn DBIConnection object DuckDB database. specified (conn = NULL), uses default connection created ddbs_default_conn() (temporary one).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"data.frame","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  ## database setup conn <- ddbs_create_conn()  ## check drivers ddbs_drivers(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the envelope (bounding box) of geometries — ddbs_envelope","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"Returns minimum bounding rectangle (envelope) geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"","code":"ddbs_envelope(   x,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. by_feature Logical. TRUE, returns one envelope per feature. FALSE (default), returns single envelope geometries combined. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"ST_Envelope returns minimum bounding rectangle (MBR) geometry polygon. points lines, creates rectangular polygon encompasses geometry. polygons, returns smallest rectangle contains entire polygon. by_feature = FALSE, geometries combined single envelope returned encompasses entire dataset.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  # input as sf, and output as sf env <- ddbs_envelope(x = argentina_ddbs, by_feature = TRUE)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  # envelope for each feature env <- ddbs_envelope(\"argentina\", conn, by_feature = TRUE)  # single envelope for entire dataset env_all <- ddbs_envelope(\"argentina\", conn, by_feature = FALSE)  # create a new table with envelopes ddbs_envelope(\"argentina\", conn, name = \"argentina_bbox\", by_feature = TRUE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_exterior_ring.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","title":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","text":"Returns exterior ring (outer boundary) polygon geometries DuckDB table using spatial extension. multi-polygons, returns exterior ring polygon component. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_exterior_ring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","text":"","code":"ddbs_exterior_ring(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_exterior_ring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_exterior_ring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_exterior_ring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracts the exterior ring of polygon geometries — ddbs_exterior_ring","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## extract exterior ring ddbs_exterior_ring(conn = conn, \"countries\")  ## extract exterior ring without using a connection ddbs_exterior_ring(countries_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs spatial filter of two geometries — ddbs_filter","title":"Performs spatial filter of two geometries — ddbs_filter","text":"Filters data spatially based spatial predicate","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs spatial filter of two geometries — ddbs_filter","text":"","code":"ddbs_filter(   x,   y,   predicate = \"intersects\",   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   distance = NULL,   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs spatial filter of two geometries — ddbs_filter","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. distance numeric value specifying distance ST_DWithin. Units correspond coordinate system geometry (e.g. degrees meters) output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs spatial filter of two geometries — ddbs_filter","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Performs spatial filter of two geometries — ddbs_filter","text":"Spatial Join Predicates: spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. quick overview commonly used ones, taking two geometries b: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching 's boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x)\tWhether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs spatial filter of two geometries — ddbs_filter","text":"","code":"if (FALSE) { # \\dontrun{ # RECOMMENDED: Efficient lazy workflow using ddbs_open_dataset library(duckspatial)  # Load data directly as lazy spatial data frames (CRS auto-detected) countries <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\", package = \"duckspatial\") )  argentina <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\", package = \"duckspatial\") )  # Lazy filter - computation stays in DuckDB neighbors <- ddbs_filter(countries, argentina, predicate = \"touches\")  # Collect to sf when needed neighbors_sf <- dplyr::collect(neighbors) |> sf::st_as_sf()   # Alternative: using sf objects directly (legacy compatibility) library(sf)  countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  result <- ddbs_filter(countries_sf, argentina_sf, predicate = \"touches\")   # Alternative: using table names in a duckdb connection conn <- ddbs_create_conn(dbdir = \"memory\")  ddbs_write_vector(conn, countries_sf, \"countries\") ddbs_write_vector(conn, argentina_sf, \"argentina\")  ddbs_filter(conn = conn, \"countries\", \"argentina\", predicate = \"touches\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":null,"dir":"Reference","previous_headings":"","what":"Flip geometries horizontally or vertically — ddbs_flip","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"Flips (reflects) geometries around centroid. Returns result sf object creates new table database. function equivalent terra::flip().","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"","code":"ddbs_flip(   x,   direction = c(\"horizontal\", \"vertical\"),   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. direction character string specifying flip direction: \"horizontal\" (default) \"vertical\". Horizontal flips across Y-axis (left-right), vertical flips across X-axis (top-bottom) by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## flip all features together as a whole (default) ddbs_flip(conn = conn, \"argentina\", direction = \"horizontal\", by_feature = FALSE)  ## flip each feature independently ddbs_flip(conn = conn, \"argentina\", direction = \"horizontal\", by_feature = TRUE)  ## flip without using a connection ddbs_flip(argentina_ddbs, direction = \"horizontal\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_format_crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a CRS object compactly for printing — ddbs_format_crs","title":"Format a CRS object compactly for printing — ddbs_format_crs","text":"Format CRS object compactly printing","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_format_crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a CRS object compactly for printing — ddbs_format_crs","text":"","code":"ddbs_format_crs(crs)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_format_crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format a CRS object compactly for printing — ddbs_format_crs","text":"crs sf crs object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_format_crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format a CRS object compactly for printing — ddbs_format_crs","text":"character string","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_generate_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random points within geometries — ddbs_generate_points","title":"Generate random points within geometries — ddbs_generate_points","text":"Generates random points within geometries DuckDB table using spatial extension. Works similarly generating random points within polygons sf. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_generate_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random points within geometries — ddbs_generate_points","text":"","code":"ddbs_generate_points(   x,   n,   seed = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_generate_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random points within geometries — ddbs_generate_points","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. n Number random points generate within geometry seed number random number generator conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_generate_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random points within geometries — ddbs_generate_points","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_generate_points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random points within geometries — ddbs_generate_points","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## generate 100 random points within each geometry ddbs_generate_points(\"argentina\", n = 100, conn)  ## generate points without using a connection ddbs_generate_points(argentina_ddbs, n = 100) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geometry_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the geometry type of input features — ddbs_geometry_type","title":"Returns the geometry type of input features — ddbs_geometry_type","text":"Returns geometry type(s) sf object DuckDB table.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geometry_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the geometry type of input features — ddbs_geometry_type","text":"","code":"ddbs_geometry_type(x, conn = NULL, by_feature = TRUE, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geometry_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the geometry type of input features — ddbs_geometry_type","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. by_feature Boolean. TRUE (default), returns geometry type feature. FALSE, returns single geometry type summary entire dataset. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geometry_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the geometry type of input features — ddbs_geometry_type","text":"factor geometry type(s)","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geometry_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the geometry type of input features — ddbs_geometry_type","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  # option 1: passing sf objects # Get geometry type for each feature ddbs_geometry_type(countries_ddbs)  # Get overall geometry type ddbs_geometry_type(countries_ddbs, by_feature = FALSE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geom_col.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the geometry column name — ddbs_geom_col","title":"Get the geometry column name — ddbs_geom_col","text":"Get geometry column name","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geom_col.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the geometry column name — ddbs_geom_col","text":"","code":"ddbs_geom_col(x)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geom_col.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the geometry column name — ddbs_geom_col","text":"x duckspatial_df object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_geom_col.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the geometry column name — ddbs_geom_col","text":"Character string geometry column name","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":null,"dir":"Reference","previous_headings":"","what":"Check first rows of the data — ddbs_glimpse","title":"Check first rows of the data — ddbs_glimpse","text":"Prints transposed table first rows DuckDB table, similarly S3 dplyr::glimpse method.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check first rows of the data — ddbs_glimpse","text":"","code":"ddbs_glimpse(   conn,   name,   crs = NULL,   crs_column = \"crs_duckspatial\",   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check first rows of the data — ddbs_glimpse","text":"conn DBIConnection object DuckDB database name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check first rows of the data — ddbs_glimpse","text":"Invisibly duckspatial_df object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check first rows of the data — ddbs_glimpse","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- ddbs_open_dataset(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## glimpse the inserted table ddbs_glimpse(conn, \"argentina\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks and installs the Spatial extension — ddbs_install","title":"Checks and installs the Spatial extension — ddbs_install","text":"Checks spatial extension available, installs DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks and installs the Spatial extension — ddbs_install","text":"","code":"ddbs_install(conn, upgrade = FALSE, quiet = FALSE, extension = \"spatial\")"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks and installs the Spatial extension — ddbs_install","text":"conn DBIConnection object DuckDB database upgrade TRUE, upgrades DuckDB extension latest version quiet logical value. TRUE, suppresses informational messages. Defaults FALSE. extension name extension install, default \"spatial\"","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks and installs the Spatial extension — ddbs_install","text":"TRUE (invisibly) successful installation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks and installs the Spatial extension — ddbs_install","text":"","code":"## load packages library(duckspatial) library(duckdb) #> Loading required package: DBI  # connect to in memory database conn <- duckdb::dbConnect(duckdb::duckdb())  # install the spatial extension ddbs_install(conn) #> ℹ spatial extension version \"2f2668d\" is already installed in this database  # disconnect from db duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":null,"dir":"Reference","previous_headings":"","what":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Transfers attribute data source spatial layer target spatial layer based area overlap geometries. function executes spatial calculations within DuckDB, enabling efficient processing large datasets without loading geometries R memory.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"","code":"ddbs_interpolate_aw(   target,   source,   tid,   sid,   extensive = NULL,   intensive = NULL,   weight = \"sum\",   output = \"sf\",   keep_NA = TRUE,   na.rm = FALSE,   join_crs = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"target sf object name persistent table DuckDB connection representing destination geometries. source sf object name persistent table DuckDB connection containing data interpolated. tid Character. name column target uniquely identifies features. sid Character. name column source uniquely identifies features. extensive Character vector. Names columns source treated spatially extensive (e.g., population counts). intensive Character vector. Names columns source treated spatially intensive (e.g., population density). weight Character. Determines denominator calculation extensive variables. Either \"sum\" (default) \"total\". See Mass Preservation Details. output Character. One \"sf\" (default) \"tibble\". \"sf\": result includes geometry column target. \"tibble\": result excludes geometry column. significantly faster consumes less storage. Note: argument also controls schema created table name provided. keep_NA Logical. TRUE (default), returns features target, even overlap source (values NA). FALSE, performs inner join, dropping non-overlapping target features. na.rm Logical. TRUE, source features NA values interpolated variables completely removed calculation (area calculations behave polygon exist). Defaults FALSE. join_crs Numeric Character (optional). EPSG code WKT CRS use area calculations. provided, target source transformed CRS within database interpolation. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"name NULL (default): Returns sf object (output=\"sf\") tibble (output=\"tibble\"). name provided: Returns TRUE invisibly creates persistent table DuckDB database. output=\"sf\", table includes geometry column. output=\"tibble\", table excludes geometry column (pure attributes).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Areal-weighted interpolation used source target geometries incongruent (align). relies assumption uniform distribution: values source polygons assumed spread evenly across polygon's area. Coordinate Systems: Area calculations highly sensitive Coordinate Reference System (CRS). function can run geographic coordinates (lon/lat), strongly recommended use projected CRS (e.g., EPSG:3857, UTM, Albers) ensure accurate area measurements. Use join_crs argument project data --fly interpolation. Extensive vs. Intensive Variables: Extensive variables counts absolute amounts (e.g., total population, number voters). source polygon split, value divided proportionally area. Intensive variables ratios, rates, densities (e.g., population density, cancer rates). source polygon split, value remains constant piece. Mass Preservation (weight argument): extensive variables, choice weight determines denominator used calculations: \"sum\" (default): denominator sum overlapping areas source feature. preserves \"mass\" variable relative target's coverage. target polygons completely cover source polygon, data technically \"lost\" falls outside target area. matches areal::aw_interpolate(weight=\"sum\"). \"total\": denominator full geometric area source feature. assumes source value distributed entire source polygon. target covers 50% source, 50% value transferred. strictly mass-preserving relative source. matches sf::st_interpolate_aw(extensive=TRUE). Note: Intensive variables always calculated using \"sum\" logic (averaging based intersection areas) regardless parameter.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Prener, C. Revord, C. (2019). areal: R package areal weighted interpolation. Journal Open Source Software, 4(37), 1221. Available : doi:10.21105/joss.01221","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"","code":"# \\donttest{ library(sf) #> Linking to GEOS 3.13.1, GDAL 3.11.4, PROJ 9.7.0; sf_use_s2() is TRUE  # 1. Prepare Data # Load NC counties (Source) and project to Albers (EPSG:5070) nc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE) nc <- st_transform(nc, 5070) nc$sid <- seq_len(nrow(nc)) # Create Source ID  # Create a target grid g <- st_make_grid(nc, n = c(10, 5)) g_sf <- st_as_sf(g) g_sf$tid <- seq_len(nrow(g_sf)) # Create Target ID  # 2. Extensive Interpolation (Counts) # Use weight = \"total\" for strict mass preservation (e.g., total births) res_ext <- ddbs_interpolate_aw(   target = g_sf, source = nc,   tid = \"tid\", sid = \"sid\",   extensive = \"BIR74\",   weight = \"total\" ) #> ✔ Query successful  # Check mass preservation sum(res_ext$BIR74, na.rm = TRUE) / sum(nc$BIR74) # Should be ~1 #> [1] 1  # 3. Intensive Interpolation (Density/Rates) # Calculates area-weighted average (e.g., assumption of uniform density) res_int <- ddbs_interpolate_aw(   target = g_sf, source = nc,   tid = \"tid\", sid = \"sid\",   intensive = \"BIR74\" ) #> ✔ Query successful  # 4. Quick Visualization par(mfrow = c(1, 2)) plot(res_ext[\"BIR74\"], main = \"Extensive (Total Count)\", border = NA)  plot(res_int[\"BIR74\"], main = \"Intensive (Weighted Avg)\", border = NA)  # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the intersection of two geometries — ddbs_intersection","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"Calculates intersection two geometries, return sf object creates new table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"","code":"ddbs_intersection(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\") ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## intersection inside the connection ddbs_intersection(\"countries\", \"argentina\", conn)  ## intersection without using a connection ddbs_intersection(countries_ddbs, argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if geometries are simple — ddbs_is_simple","title":"Check if geometries are simple — ddbs_is_simple","text":"Checks geometries simple (self-intersections) DuckDB table using spatial extension. Returns result sf object boolean simplicity column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if geometries are simple — ddbs_is_simple","text":"","code":"ddbs_is_simple(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if geometries are simple — ddbs_is_simple","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if geometries are simple — ddbs_is_simple","text":"new_column = NULL returns logical vector. new_column NULL, output depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if geometries are simple — ddbs_is_simple","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## check simplicity ddbs_is_simple(\"argentina\", conn)  ## check simplicity without using a connection ddbs_is_simple(argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if geometries are valid — ddbs_is_valid","title":"Check if geometries are valid — ddbs_is_valid","text":"Checks validity geometries DuckDB table using spatial extension. Returns result sf object boolean validity column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if geometries are valid — ddbs_is_valid","text":"","code":"ddbs_is_valid(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if geometries are valid — ddbs_is_valid","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if geometries are valid — ddbs_is_valid","text":"new_column = NULL returns logical vector. new_column NULL, output depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if geometries are valid — ddbs_is_valid","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## check validity ddbs_is_valid(\"argentina\", conn)  ## check validity without using a connection ddbs_is_valid(argentina_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs spatial joins of two geometries — ddbs_join","title":"Performs spatial joins of two geometries — ddbs_join","text":"Performs spatial joins two geometries, returns sf object creates new table DuckDB database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs spatial joins of two geometries — ddbs_join","text":"","code":"ddbs_join(   x,   y,   join = \"intersects\",   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs spatial joins of two geometries — ddbs_join","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn join geometry predicate function. Defaults \"intersects\". See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs spatial joins of two geometries — ddbs_join","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Performs spatial joins of two geometries — ddbs_join","text":"Spatial Join Predicates: spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. quick overview commonly used ones, taking two geometries b: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching 's boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x)\tWhether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs spatial joins of two geometries — ddbs_join","text":"","code":"if (FALSE) { # \\dontrun{ # RECOMMENDED: Efficient lazy workflow using ddbs_open_dataset library(duckspatial)  # Load data directly as lazy spatial data frames (CRS auto-detected) countries <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\", package = \"duckspatial\") )  # Create random points n <- 100 points <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90) ) |>    sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326) |>   as_duckspatial_df()  # Lazy join - computation stays in DuckDB result <- ddbs_join(points, countries, join = \"within\")  # Collect to sf when needed result_sf <- dplyr::collect(result) |> sf::st_as_sf() plot(result_sf[\"CNTR_NAME\"])   # Alternative: using sf objects directly (legacy compatibility) library(sf)  countries_sf <- sf::st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  output <- duckspatial::ddbs_join(     x = points,     y = countries_sf,     join = \"within\" )   # Alternative: using table names in a duckdb connection conn <- duckspatial::ddbs_create_conn()  ddbs_write_vector(conn, points, \"points\", overwrite = TRUE) ddbs_write_vector(conn, countries_sf, \"countries\", overwrite = TRUE)  output2 <- ddbs_join(     conn = conn,     x = \"points\",     y = \"countries\",     join = \"within\" )  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the length of geometries — ddbs_length","title":"Calculates the length of geometries — ddbs_length","text":"Calculates length geometries (meters) DuckDB table sf object Returns result sf object length column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the length of geometries — ddbs_length","text":"","code":"ddbs_length(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the length of geometries — ddbs_length","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the length of geometries — ddbs_length","text":"new_column = NULL returns units vector meters. new_column NULL, output depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates the length of geometries — ddbs_length","text":"input geometry EPSG:4326, function uses ST_Length_Spheroid, use GeographicLib library calculating length using ellipsoidal model earth. method highly accurate calculating length line geometry considering curvature earth, also slowest. input geometry projected CRS, function use ST_Length calculate length meters. cases, function use ST_Length_Spheroid display warning.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculates the length of geometries — ddbs_length","text":"https://geographiclib.sourceforge.io/","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the length of geometries — ddbs_length","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data rivers_ddbs <- ddbs_open_dataset(   system.file(\"spatial/rivers.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, rivers_ddbs, \"rivers\")  ## calculate length (returns sf object with length column) ddbs_length(\"rivers\", conn)  ## calculate length with custom column name ddbs_length(\"rivers\", conn, new_column = \"length_meters\")  ## create a new table with length calculations ddbs_length(\"rivers\", conn, name = \"rivers_with_length\", new_column = \"length_meters\")  ## calculate length in a sf object (without a connection) ddbs_length(rivers_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":null,"dir":"Reference","previous_headings":"","what":"Check tables and schemas inside a database — ddbs_list_tables","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"Check tables schemas inside database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"","code":"ddbs_list_tables(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"conn DBIConnection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"data.frame","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  ## create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read some data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## insert into the database ddbs_write_vector(conn, argentina_ddbs, \"argentina\") ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## list tables in the database ddbs_list_tables(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Loads the Spatial extension — ddbs_load","title":"Loads the Spatial extension — ddbs_load","text":"Checks spatial extension installed, loads DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loads the Spatial extension — ddbs_load","text":"","code":"ddbs_load(conn, quiet = FALSE, extension = \"spatial\")"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loads the Spatial extension — ddbs_load","text":"conn DBIConnection object DuckDB database quiet logical value. TRUE, suppresses informational messages. Defaults FALSE. extension name extension load, default \"spatial\"","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loads the Spatial extension — ddbs_load","text":"TRUE (invisibly) successful installation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Loads the Spatial extension — ddbs_load","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(duckdb)  ## connect to in memory database conn <- duckdb::dbConnect(duckdb::duckdb())  ## install the spatial exntesion ddbs_install(conn) ddbs_load(conn)  ## disconnect from db duckdb::dbDisconnect(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates polygons from linestring geometries — ddbs_make_polygon","title":"Creates polygons from linestring geometries — ddbs_make_polygon","text":"Constructs polygon geometries linestring geometries DuckDB table using spatial extension. input linestrings must closed (first last points must identical). Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates polygons from linestring geometries — ddbs_make_polygon","text":"","code":"ddbs_make_polygon(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_polygon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates polygons from linestring geometries — ddbs_make_polygon","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_polygon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates polygons from linestring geometries — ddbs_make_polygon","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_polygon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates polygons from linestring geometries — ddbs_make_polygon","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## extract exterior ring as linestring, then convert back to polygon ring_ddbs <- ddbs_exterior_ring(conn = conn, \"argentina\") ddbs_make_polygon(conn = conn, ring_ddbs, name = \"argentina_poly\")  ## create polygon without using a connection ddbs_make_polygon(ring_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Make invalid geometries valid — ddbs_make_valid","title":"Make invalid geometries valid — ddbs_make_valid","text":"Attempts make invalid geometries valid DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make invalid geometries valid — ddbs_make_valid","text":"","code":"ddbs_make_valid(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make invalid geometries valid — ddbs_make_valid","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make invalid geometries valid — ddbs_make_valid","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make invalid geometries valid — ddbs_make_valid","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## make valid ddbs_make_valid(\"countries\", conn)  ## make valid without using a connection ddbs_make_valid(countries_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_open_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","title":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","text":"Reads spatial data directly disk using DuckDB's spatial extension native Parquet reader, returning duckspatial_df object lazy processing.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_open_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","text":"","code":"ddbs_open_dataset(   path,   crs = NULL,   layer = NULL,   geom_col = NULL,   conn = NULL,   parquet_binary_as_string = NULL,   parquet_file_row_number = NULL,   parquet_filename = NULL,   parquet_hive_partitioning = NULL,   parquet_union_by_name = NULL,   parquet_encryption_config = NULL,   read_shp_mode = c(\"ST_ReadSHP\", \"GDAL\"),   read_osm_mode = c(\"GDAL\", \"ST_ReadOSM\"),   shp_encoding = NULL,   gdal_spatial_filter = NULL,   gdal_spatial_filter_box = NULL,   gdal_keep_wkb = NULL,   gdal_max_batch_size = NULL,   gdal_sequential_layer_scan = NULL,   gdal_sibling_files = NULL,   gdal_allowed_drivers = NULL,   gdal_open_options = NULL )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_open_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","text":"path Path spatial file. Supports Parquet (.parquet, optional GeoParquet metadata), GeoJSON, GeoPackage, Shapefile, FlatGeoBuf, OSM PBF, GDAL-supported formats. crs Coordinate reference system. Can EPSG code (e.g., 4326), CRS string, sf crs object. NULL (default), attempts auto-detect file. layer Layer name index read (ST_Read ). Default NULL (first layer). geom_col Name geometry column. Default NULL, attempts auto-detection. conn DuckDB connection use. NULL, uses default connection. parquet_binary_as_string Logical. (Parquet) TRUE, load binary columns strings. parquet_file_row_number Logical. (Parquet) TRUE, include file_row_number column. parquet_filename Logical. (Parquet) TRUE, include filename column. parquet_hive_partitioning Logical. (Parquet) TRUE, interpret path Hive partitioned. parquet_union_by_name Logical. (Parquet) TRUE, unify columns name. parquet_encryption_config List/Struct. (Parquet) Encryption configuration (advanced). read_shp_mode Mode reading Shapefiles. \"ST_ReadSHP\" (default, fast native reader) \"GDAL\" (ST_Read). read_osm_mode Mode reading OSM PBF files. \"GDAL\" (default, ST_Read) \"ST_ReadOSM\" (fast native reader, geometry). shp_encoding Encoding Shapefiles using \"ST_ReadSHP\" (e.g., \"UTF-8\", \"ISO-8859-1\"). gdal_spatial_filter Optional WKB geometry (raw vector hex string) filter spatially (ST_Read ). gdal_spatial_filter_box Optional bounding box (numeric vector c(minx, miny, maxx, maxy)) (ST_Read ). gdal_keep_wkb Logical. TRUE, return WKB blobs instead GEOMETRY type (ST_Read ). gdal_max_batch_size Integer. Maximum batch size reading (ST_Read ). gdal_sequential_layer_scan Logical. TRUE, scan layers sequentially (ST_Read ). gdal_sibling_files Character vector. List sibling files (ST_Read ). gdal_allowed_drivers Character vector. List allowed GDAL drivers (ST_Read ). gdal_open_options Character vector. Driver-specific open options (ST_Read ).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_open_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","text":"duckspatial_df object.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_open_dataset.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Open spatial dataset lazily via DuckDB — ddbs_open_dataset","text":"function inspired dataset opening logic duckdbfs package (https://github.com/cboettig/duckdbfs).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set global duckspatial options — ddbs_options","title":"Get or set global duckspatial options — ddbs_options","text":"Get set global duckspatial options","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set global duckspatial options — ddbs_options","text":"","code":"ddbs_options(output_type = NULL)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set global duckspatial options — ddbs_options","text":"output_type Character string. Controls default return type spatial operations. Must one : \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB. \"sf\": Eagerly collected sf object (-memory). \"tibble\": Eagerly collected tibble without geometry. \"raw\": Eagerly collected tibble geometry raw WKB bytes. \"geoarrow\": Eagerly collected tibble geometry geoarrow_vctr. NULL (default), existing option changed.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set global duckspatial options — ddbs_options","text":"Invisibly returns list containing currently set options.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set global duckspatial options — ddbs_options","text":"","code":"if (FALSE) { # \\dontrun{ # Set default output to sf ddbs_options(output_type = \"sf\")  # Set default output to tibble ddbs_options(output_type = \"tibble\")  # Set default output to duckspatial_df ddbs_options(output_type = \"duckspatial_df\")  # Check current settings ddbs_options() } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial predicate operations — ddbs_predicate","title":"Spatial predicate operations — ddbs_predicate","text":"Computes spatial relationships two geometry datasets using DuckDB's spatial extension. Returns list element corresponds row x, containing indices (IDs) rows y satisfy specified spatial predicate.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial predicate operations — ddbs_predicate","text":"","code":"ddbs_predicate(   x,   y,   predicate = \"intersects\",   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   distance = NULL,   quiet = FALSE )  ddbs_intersects(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_covers(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_touches(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_is_within_distance(   x,   y,   distance = NULL,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_disjoint(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_within(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_contains(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_overlaps(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_crosses(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_equals(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_covered_by(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_intersects_extent(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_contains_properly(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )  ddbs_within_properly(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial predicate operations — ddbs_predicate","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. distance numeric value specifying distance ST_DWithin. Units correspond coordinate system geometry (e.g. degrees meters) quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial predicate operations — ddbs_predicate","text":"list length equal number rows x. element contains: integer vector row indices y satisfy predicate corresponding geometry x, character vector id_y supplied. names list elements: integer row numbers x, values id_x provided. match x y returns NULL","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial predicate operations — ddbs_predicate","text":"function provides unified interface spatial predicate operations DuckDB's spatial extension. performs pairwise comparisons geometries x y using specified predicate.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"available-predicates","dir":"Reference","previous_headings":"","what":"Available Predicates","title":"Spatial predicate operations — ddbs_predicate","text":"intersects: Geometries share least one point covers: Geometry x completely covers geometry y touches: Geometries share boundary interiors intersect disjoint: Geometries points common within: Geometry x completely inside geometry y dwithin: Geometry x completely within distance geometry y contains: Geometry x completely contains geometry y overlaps: Geometries share points crosses: Geometries interior points common equals: Geometries spatially equal covered_by: Geometry x completely covered geometry y intersects_extent: Bounding boxes geometries intersect (faster less precise) contains_properly: Geometry x contains geometry y without boundary contact within_properly: Geometry x within geometry y without boundary contact x y DuckDB tables, automatically copied temporary -memory DuckDB database (unless connection supplied via conn). id_x id_y may used replace default integer indices values identifier column x y, respectively.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial predicate operations — ddbs_predicate","text":"","code":"if (FALSE) { # \\dontrun{ ## Load packages library(duckspatial) library(dplyr)  ## create in-memory DuckDB database conn <- ddbs_create_conn(dbdir = \"memory\")  ## read countries data, and rivers countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") ) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  rivers_ddbs <- ddbs_open_dataset(   system.file(\"spatial/rivers.geojson\",    package = \"duckspatial\") ) |>   ddbs_transform(ddbs_crs(countries_ddbs))  ## Store in DuckDB ddbs_write_vector(conn, countries_ddbs, \"countries\") ddbs_write_vector(conn, rivers_ddbs, \"rivers\")  ## Example 1: Check which rivers intersect each country ddbs_predicate(countries_ddbs, rivers_ddbs, predicate = \"intersects\") ddbs_intersects(countries_ddbs, rivers_ddbs)  ## Example 2: Find neighboring countries ddbs_predicate(   countries_ddbs,    countries_ddbs,    predicate = \"touches\",   id_x = \"NAME_ENGL\",    id_y = \"NAME_ENGL\" )  ddbs_touches(   countries_ddbs,    countries_ddbs,    id_x = \"NAME_ENGL\",    id_y = \"NAME_ENGL\" )  ## Example 3: Find rivers that don't intersect countries ddbs_predicate(   countries_ddbs,    rivers_ddbs,    predicate = \"disjoint\",   id_x = \"NAME_ENGL\",    id_y = \"RIVER_NAME\" )  ## Example 4: Use table names inside duckdb ddbs_predicate(\"countries\", \"rivers\", predicate = \"within\", conn, id_x = \"NAME_ENGL\") ddbs_within(\"countries\", \"rivers\", conn,  id_x = \"NAME_ENGL\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert geometries to QuadKey tiles — ddbs_quadkey","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"Converts POINT geometries QuadKey tile representations specified zoom level. QuadKeys hierarchical spatial indexing system used mapping services like Bing Maps.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"","code":"ddbs_quadkey(   x,   level = 10,   field = NULL,   fun = \"mean\",   background = NA,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = \"polygon\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. level integer specifying zoom level QuadKey generation (1-23). Higher values provide finer spatial resolution. Default 10. field Character string specifying field name aggregation. fun aggregation function multiple quadkeys (e.g. \"mean\", \"min\", \"max\", \"sum\"). background numeric. Default value raster cells without values. used output = \"raster\" conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character string specifying output format. One : \"polygon\" - Returns QuadKey tile boundaries duckspatial_df (default) \"raster\" - Returns QuadKey values SpatRaster \"tilexy\" - Returns tile XY coordinates tibble overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"Depends output argument polygon (default): lazy spatial data frame backed dbplyr/DuckDB. raster: eagerly collected SpatRaster object R memory. tilexy: eagerly collected tibble without geometry R memory. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"QuadKeys divide world hierarchical grid tiles, tile subdivided four smaller tiles next zoom level. function wraps DuckDB's ST_QuadKey spatial function generate tiles input geometries. Note creating table inside connection generate non-spatial table, therefore, read ddbs_read_vector().","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_quadkey.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert geometries to QuadKey tiles — ddbs_quadkey","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf) library(terra)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## create random points in Argentina argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\")) rand_sf <- st_sample(argentina_sf, 100) |> st_as_sf() rand_sf[\"var\"] <- runif(100)  ## store in duckdb ddbs_write_vector(conn, rand_sf, \"rand_sf\")  ## generate QuadKey polygons at zoom level 8 qkey_ddbs <- ddbs_quadkey(conn = conn, \"rand_sf\", level = 8, output = \"polygon\")  ## generate QuadKey raster with custom field name qkey_rast <- ddbs_quadkey(conn = conn, \"rand_sf\", level = 6, output = \"raster\", field = \"var\")  ## generate Quadkey XY tiles qkey_tiles_tbl <- ddbs_quadkey(conn = conn, \"rand_sf\", level = 10, output = \"tilexy\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Load spatial vector data from DuckDB into R — ddbs_read_vector","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"Retrieves data DuckDB table, view, Arrow view geometry column, converts R sf object. function works persistent tables created ddbs_write_vector temporary Arrow views created ddbs_register_vector.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"","code":"ddbs_read_vector(   conn,   name,   crs = NULL,   crs_column = \"crs_duckspatial\",   clauses = NULL,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"conn DBIConnection object DuckDB database name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. clauses character, additional SQL code modify query table (e.g. \"...\", \"ORDER ...\") quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"sf object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## create random points random_points <- data.frame(   id = 1:5,   x = runif(5, min = -180, max = 180),   y = runif(5, min = -90, max = 90) )  ## convert to sf sf_points <- st_as_sf(random_points, coords = c(\"x\", \"y\"), crs = 4326)  ## Example 1: Write and read persistent table ddbs_write_vector(conn, sf_points, \"points\") ddbs_read_vector(conn, \"points\", crs = 4326)  ## Example 2: Register and read Arrow view (faster, temporary) ddbs_register_vector(conn, sf_points, \"points_view\") ddbs_read_vector(conn, \"points_view\", crs = 4326)  ## disconnect from db ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"function registers Simple Features (SF) object temporary Arrow-backed view DuckDB database. zero-copy operation significantly faster ddbs_write_vector workflows require data permanently materialized database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"","code":"ddbs_register_vector(conn, data, name, overwrite = FALSE, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"conn DBIConnection object DuckDB database data sf object write DuckDB database, path local file can read ST_READ name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"TRUE (invisibly) successful registration.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial) library(sf)  conn <- ddbs_create_conn(\"memory\")  nc <- st_read(system.file(\"shape/nc.shp\", package=\"sf\"), quiet = TRUE)  ddbs_register_vector(conn, nc, \"nc_arrow_view\")  dbGetQuery(conn, \"SELECT COUNT(*) FROM nc_arrow_view;\")  ddbs_stop_conn(conn, shutdown = TRUE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate geometries around centroid — ddbs_rotate","title":"Rotate geometries around centroid — ddbs_rotate","text":"Rotates geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate geometries around centroid — ddbs_rotate","text":"","code":"ddbs_rotate(   x,   angle,   units = c(\"degrees\", \"radians\"),   by_feature = FALSE,   center_x = NULL,   center_y = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate geometries around centroid — ddbs_rotate","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. angle numeric value specifying rotation angle units character string specifying angle units: \"degrees\" (default) \"radians\" by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. center_x numeric value X coordinate rotation center. NULL, rotates around centroid geometry center_y numeric value Y coordinate rotation center. NULL, rotates around centroid geometry conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate geometries around centroid — ddbs_rotate","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate geometries around centroid — ddbs_rotate","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## rotate 45 degrees ddbs_rotate(conn = conn, \"argentina\", angle = 45)  ## rotate 90 degrees around a specific point ddbs_rotate(conn = conn, \"argentina\", angle = 90, center_x = -64, center_y = -34)  ## rotate without using a connection ddbs_rotate(argentina_ddbs, angle = 45) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate 3D geometries around an axis — ddbs_rotate_3d","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"Rotates 3D geometries sf object DuckDB table around X, Y, Z axis. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"","code":"ddbs_rotate_3d(   x,   angle,   units = c(\"degrees\", \"radians\"),   axis = \"x\",   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. angle numeric value specifying rotation angle units character string specifying angle units: \"degrees\" (default) \"radians\" axis character string specifying rotation axis: \"x\", \"y\", \"z\" (default = \"x\"). geometry rotates around axis conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(dplyr)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read 3D data countries_ddbs <- ddbs_open_dataset(  system.file(\"spatial/countries.geojson\",   package = \"duckspatial\") ) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## rotate 45 degrees around X axis (pitch) ddbs_rotate_3d(conn = conn, \"countries\", angle = 45, axis = \"x\")  ## rotate 90 degrees around Y axis (yaw) ddbs_rotate_3d(conn = conn, \"countries\", angle = 30, axis = \"y\")  ## rotate 180 degrees around Z axis (roll) ddbs_rotate_3d(conn = conn, \"countries\", angle = 180, axis = \"z\")  ## rotate without using a connection ddbs_rotate_3d(countries_ddbs, angle = 45, axis = \"z\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale geometries by X and Y factors — ddbs_scale","title":"Scale geometries by X and Y factors — ddbs_scale","text":"Scales geometries around centroid geometry. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale geometries by X and Y factors — ddbs_scale","text":"","code":"ddbs_scale(   x,   x_scale = 1,   y_scale = 1,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale geometries by X and Y factors — ddbs_scale","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. x_scale numeric value specifying scaling factor X direction (default = 1) y_scale numeric value specifying scaling factor Y direction (default = 1) by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale geometries by X and Y factors — ddbs_scale","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale geometries by X and Y factors — ddbs_scale","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(dplyr)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") ) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## scale to 150% in both directions ddbs_scale(conn = conn, \"countries\", x_scale = 1.5, y_scale = 1.5)  ## scale to 200% horizontally, 50% vertically ddbs_scale(conn = conn, \"countries\", x_scale = 2, y_scale = 0.5)  ## scale all features together (default) ddbs_scale(countries_ddbs, x_scale = 1.5, y_scale = 1.5, by_feature = FALSE)  ## scale each feature independently ddbs_scale(countries_ddbs, x_scale = 1.5, y_scale = 1.5, by_feature = TRUE)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_set_resources.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set connection resources — ddbs_set_resources","title":"Get or set connection resources — ddbs_set_resources","text":"Configure technical system settings DuckDB connection, memory limits CPU threads.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_set_resources.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set connection resources — ddbs_set_resources","text":"","code":"ddbs_set_resources(conn, threads = NULL, memory_limit_gb = NULL)  ddbs_get_resources(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_set_resources.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set connection resources — ddbs_set_resources","text":"conn DBIConnection object DuckDB database threads Integer. Number threads use. NULL (default), setting changed, DuckDB engine use available cores detects (warning, shared HPC nodes detected number cores might total number cores node, per-job allocation). memory_limit_gb Numeric. Memory limit GB. NULL (default), setting changed, DuckDB engine use 80% available operating system memory detects (warning, shared HPC nodes detected memory might full node memory, per-job allocation).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_set_resources.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set connection resources — ddbs_set_resources","text":"ddbs_set_resources(), invisibly returns list containing current system settings; ddbs_get_resources(), visibly returns list direct inspection.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_set_resources.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set connection resources — ddbs_set_resources","text":"","code":"if (FALSE) { # \\dontrun{ # Create a connection conn <- ddbs_create_conn()  # Set resources: 1 thread and 4GB ddbs_set_resources(conn, threads = 1, memory_limit_gb = 4)  # Check current settings ddbs_get_resources(conn)  ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":null,"dir":"Reference","previous_headings":"","what":"Shear geometries — ddbs_shear","title":"Shear geometries — ddbs_shear","text":"Applies shear transformation geometries sf object DuckDB table. Returns result sf object creates new table database. Shearing skews geometry shifting coordinates proportionally.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shear geometries — ddbs_shear","text":"","code":"ddbs_shear(   x,   x_shear = 0,   y_shear = 0,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shear geometries — ddbs_shear","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. x_shear numeric value specifying shear factor X direction (default = 0). unit Y, X coordinates shifted amount y_shear numeric value specifying shear factor Y direction (default = 0). unit X, Y coordinates shifted amount by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shear geometries — ddbs_shear","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shear geometries — ddbs_shear","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(dplyr)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") ) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## shear in X direction (creates italic-like effect) ddbs_shear(conn = conn, \"countries\", x_shear = 0.3, y_shear = 0)  ## shear in Y direction ddbs_shear(conn = conn, \"countries\", x_shear = 0, y_shear = 0.3)  ## shear in both directions ddbs_shear(conn = conn, \"countries\", x_shear = 0.2, y_shear = 0.2)  ## shear without using a connection ddbs_shear(countries_ddbs, x_shear = 0.3, y_shear = 0) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift geometries by X and Y offsets — ddbs_shift","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"Shifts (translates) geometries sf object DuckDB table. Returns result sf object creates new  table database. function equivalent terra::shift().","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"","code":"ddbs_shift(   x,   dx = 0,   dy = 0,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. dx numeric value specifying shift X direction (longitude/easting) dy numeric value specifying shift Y direction (latitude/northing) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## shift 10 degrees east and 5 degrees north ddbs_shift(conn = conn, \"argentina\", dx = 10, dy = 5)  ## shift without using a connection ddbs_shift(argentina_ddbs, dx = 10, dy = 5) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify geometries — ddbs_simplify","title":"Simplify geometries — ddbs_simplify","text":"Simplifies geometries DuckDB table using Douglas-Peucker algorithm via spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify geometries — ddbs_simplify","text":"","code":"ddbs_simplify(   x,   tolerance,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify geometries — ddbs_simplify","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. tolerance Tolerance distance simplification. Larger values result simplified geometries. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify geometries — ddbs_simplify","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify geometries — ddbs_simplify","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, countries_ddbs, \"countries\")  ## simplify with tolerance of 0.01 ddbs_simplify(\"countries\", tolerance = 0.01, conn)  ## simplify without using a connection ddbs_simplify(countries_ddbs, tolerance = 0.01) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_sitrep.html","id":null,"dir":"Reference","previous_headings":"","what":"Report duckspatial configuration status — ddbs_sitrep","title":"Report duckspatial configuration status — ddbs_sitrep","text":"Displays useful information current configuration, including global options status default DuckDB connection.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_sitrep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report duckspatial configuration status — ddbs_sitrep","text":"","code":"ddbs_sitrep()"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_sitrep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report duckspatial configuration status — ddbs_sitrep","text":"Invisibly returns list current status configuration.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_sitrep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report duckspatial configuration status — ddbs_sitrep","text":"","code":"ddbs_sitrep() #>  #> ── duckspatial Status Report ─────────────────────────────────────────────────── #>  #> ── Global Options ── #>  #> • Output Type: \"duckspatial_df\" #>  #> ── Default Connection ── #>  #> ! No default connection active (will be created on demand)."},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":null,"dir":"Reference","previous_headings":"","what":"Close a duckdb connection — ddbs_stop_conn","title":"Close a duckdb connection — ddbs_stop_conn","text":"Close duckdb connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Close a duckdb connection — ddbs_stop_conn","text":"","code":"ddbs_stop_conn(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Close a duckdb connection — ddbs_stop_conn","text":"conn DBIConnection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Close a duckdb connection — ddbs_stop_conn","text":"TRUE (invisibly) successful disconnection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Close a duckdb connection — ddbs_stop_conn","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial)  ## create an in-memory duckdb database conn <- ddbs_create_conn(dbdir = \"memory\")  ## close the connection ddbs_stop_conn(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_temp_view_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate unique temporary view name — ddbs_temp_view_name","title":"Generate unique temporary view name — ddbs_temp_view_name","text":"Creates unique name temporary views avoid collisions.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_temp_view_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate unique temporary view name — ddbs_temp_view_name","text":"","code":"ddbs_temp_view_name()"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_temp_view_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate unique temporary view name — ddbs_temp_view_name","text":"Character string unique view name","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform coordinate reference system of geometries — ddbs_transform","title":"Transform coordinate reference system of geometries — ddbs_transform","text":"Transforms geometries DuckDB table different coordinate reference system using spatial extension. Works similarly sf::st_transform(). Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform coordinate reference system of geometries — ddbs_transform","text":"","code":"ddbs_transform(   x,   y,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform coordinate reference system of geometries — ddbs_transform","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Target CRS. Can : character string EPSG code (e.g., \"EPSG:4326\") sf object (uses CRS) Name DuckDB table (uses CRS) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform coordinate reference system of geometries — ddbs_transform","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform coordinate reference system of geometries — ddbs_transform","text":"","code":"if (FALSE) { # \\dontrun{ ## load package library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_ddbs <- ddbs_open_dataset(   system.file(\"spatial/argentina.geojson\",    package = \"duckspatial\") )  ## store in duckdb ddbs_write_vector(conn, argentina_ddbs, \"argentina\")  ## transform to different CRS using EPSG code ddbs_transform(\"argentina\", \"EPSG:3857\", conn)  ## transform to match CRS of another object argentina_3857_ddbs <- ddbs_transform(argentina_ddbs, \"EPSG:3857\") ddbs_write_vector(conn, argentina_3857_ddbs, \"argentina_3857\") ddbs_transform(\"argentina\", argentina_3857_ddbs, conn)  ## transform to match CRS of another DuckDB table ddbs_transform(\"argentina\", \"argentina_3857\", conn)  ## transform without using a connection ddbs_transform(argentina_ddbs, \"EPSG:3857\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":null,"dir":"Reference","previous_headings":"","what":"Union and combine geometries — ddbs_union_funs","title":"Union and combine geometries — ddbs_union_funs","text":"Perform union combine operations spatial geometries DuckDB. ddbs_union() - Union geometries one, perform pairwise union two datasets ddbs_union_agg() - Union geometries grouped one columns ddbs_combine() - Combine geometries MULTI-geometry without dissolving boundaries","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Union and combine geometries — ddbs_union_funs","text":"","code":"ddbs_union(   x,   y = NULL,   by_feature = FALSE,   conn = NULL,   conn_x = NULL,   conn_y = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )  ddbs_combine(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )  ddbs_union_agg(   x,   by,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   output = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Union and combine geometries — ddbs_union_funs","text":"x Input spatial data. Can : duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn Data returned object. y Input spatial data. Can : NULL (default): performs union x duckspatial_df object (lazy spatial data frame via dbplyr) sf object tbl_lazy dbplyr character string naming table/view conn by_feature Logical. y provided: FALSE (default) - Union geometries x y single geometry TRUE - Perform row--row union matching features x y (requires number rows) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. conn_x DBIConnection object DuckDB database input x. NULL (default), resolved conn extracted x. conn_y DBIConnection object DuckDB database input y. NULL (default), resolved conn extracted y. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs Deprecated coordinates reference system data. Specify data crs_column, know CRS. crs_column Deprecated character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. output Character. Controls return type. Options: \"duckspatial_df\" (default): Lazy spatial data frame backed dbplyr/DuckDB \"sf\": Eagerly collected sf object (uses memory) \"tibble\": Eagerly collected tibble without geometry \"raw\": Eagerly collected tibble WKB geometry (list raw vectors) \"geoarrow\": Eagerly collected tibble geoarrow geometry (geoarrow_vctr) Can set globally via ddbs_options(output_type = \"...\") per-function via argument. Per-function overrides global setting. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE. Character vector specifying one column names group computing unions. Geometries unioned within group. Default NULL","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Union and combine geometries — ddbs_union_funs","text":"Depends output argument (global preference set ddbs_options): duckspatial_df (default): lazy spatial data frame backed dbplyr/DuckDB. sf: eagerly collected sf object R memory. tibble: eagerly collected tibble without geometry R memory. raw: eagerly collected tibble WKB geometry (conversion). geoarrow: eagerly collected tibble geometry converted geoarrow_vctr. name provided, result also written table view DuckDB function returns TRUE (invisibly).","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"ddbs-union-x-y-by-feature-","dir":"Reference","previous_headings":"","what":"ddbs_union(x, y, by_feature)","title":"Union and combine geometries — ddbs_union_funs","text":"Performs geometric union operations dissolve internal boundaries: y = NULL: Unions geometries x single geometry y != NULL by_feature = FALSE: Unions geometries x y single geometry y != NULL by_feature = TRUE: Performs row-wise union, pairing first geometry x first y, second second, etc.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"ddbs-union-agg-x-by-","dir":"Reference","previous_headings":"","what":"ddbs_union_agg(x, by)","title":"Union and combine geometries — ddbs_union_funs","text":"Groups geometries one columns, unions geometries within group. Useful dissolving boundaries features share common attributes.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"ddbs-combine-x-","dir":"Reference","previous_headings":"","what":"ddbs_combine(x)","title":"Union and combine geometries — ddbs_union_funs","text":"Combines geometries single MULTI-geometry (e.g., MULTIPOLYGON, MULTILINESTRING) without dissolving shared boundaries. faster union preserves original geometry boundaries.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union_funs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Union and combine geometries — ddbs_union_funs","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(dplyr) library(duckspatial)  ## create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_ddbs <- ddbs_open_dataset(   system.file(\"spatial/countries.geojson\",    package = \"duckspatial\") ) |>    filter(ISO3_CODE != \"ATA\")  rivers_ddbs <- ddbs_open_dataset(   system.file(\"spatial/rivers.geojson\",    package = \"duckspatial\") ) |>   ddbs_transform(\"EPSG:4326\")  ## combine countries into a single MULTI-geometry ## (without solving boundaries) combined_countries_ddbs <- ddbs_combine(countries_ddbs)  ## combine countries into a single MULTI-geometry ## (solving boundaries) union_countries_ddbs <- ddbs_union(countries_ddbs)  ## union of geometries of two objects, into 1 geometry union_countries_rivers_ddbs <- ddbs_union(countries_ddbs, rivers_ddbs) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Write spatial dataset to disk — ddbs_write_dataset","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"Writes spatial data disk using DuckDB's COPY command. Supports Parquet (native) various GDAL spatial formats. Format auto-detected file extension common formats, can specified explicitly via gdal_driver.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"","code":"ddbs_write_dataset(   data,   path,   gdal_driver = NULL,   conn = NULL,   overwrite = FALSE,   crs = NULL,   options = list(),   partitioning = if (inherits(data, c(\"tbl_lazy\", \"duckspatial_df\")))     dplyr::group_vars(data) else NULL,   parquet_compression = NULL,   parquet_row_group_size = NULL,   layer_creation_options = NULL,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"data duckspatial_df, tbl_lazy (DuckDB), sf object. path Path output file. gdal_driver GDAL driver name writing spatial formats. NULL (default), driver auto-detected file extension common formats: .geojson, .json → \"GeoJSON\" .shp → \"ESRI Shapefile\" .gpkg → \"GPKG\" .fgb → \"FlatGeobuf\" .kml → \"KML\" .gpx → \"GPX\" .gml → \"GML\" .sqlite → \"SQLite\" non-standard file extensions (e.g., .dat, .xyz) explicitly override auto-detection, specify exact driver name appears ddbs_drivers()$short_name. Examples: gdal_driver = \"GeoJSON\", gdal_driver = \"ESRI Shapefile\". Note: specify driver match file extension (e.g., path = \"output.shp\" gdal_driver = \"GeoJSON\"), warning issued explicit driver choice honored (creating GeoJSON file .shp extension). function validates specified driver available writable system. Note: .parquet .csv files use native DuckDB writers require GDAL driver. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. overwrite Logical. TRUE, overwrites existing file. crs Output CRS (e.g., \"EPSG:4326\"). Passed GDAL SRS option. Ignored Parquet. options Named list additional options passed COPY. partitioning Character vector columns partition (Parquet/CSV ). parquet_compression Compression codec Parquet. parquet_row_group_size Row group size Parquet. layer_creation_options GDAL layer creation options. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"path invisibly.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"function inspired builds upon logic found duckdbfs package (https://github.com/cboettig/duckdbfs), particularly write_dataset write_geo functions. advanced features like cloud storage (S3) support, duckdbfs package highly recommended.","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write spatial dataset to disk — ddbs_write_dataset","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial)  # Read example data path <- system.file(\"spatial/countries.geojson\", package = \"duckspatial\") ds <- ddbs_open_dataset(path)  # Auto-detect format from extension ddbs_write_dataset(ds, \"output.geojson\") ddbs_write_dataset(ds, \"output.gpkg\") ddbs_write_dataset(ds, \"output.parquet\")  # Explicit GDAL driver for non-standard extension ddbs_write_dataset(ds, \"mydata.dat\", gdal_driver = \"GeoJSON\")  # See available drivers on your system drivers <- ddbs_drivers() writable <- drivers[drivers$can_create == TRUE, ] head(writable)  # CRS override ddbs_write_dataset(ds, \"output_3857.geojson\", crs = \"EPSG:3857\")  # Overwrite existing file ddbs_write_dataset(ds, \"output.gpkg\", overwrite = TRUE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Write an SF Object to a DuckDB Database — ddbs_write_vector","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"function writes Simple Features (SF) object DuckDB database new table. table created specified schema DuckDB database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"","code":"ddbs_write_vector(   conn,   data,   name,   overwrite = FALSE,   temp_view = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"conn DBIConnection object DuckDB database data sf object write DuckDB database, path local file can read ST_READ name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. temp_view TRUE, registers sf object temporary Arrow-backed database 'view' using ddbs_register_vector instead creating persistent table. much faster view persist. Defaults FALSE. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"TRUE (invisibly) successful import","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## create random points random_points <- data.frame(   id = 1:5,   x = runif(5, min = -180, max = 180),  # Random longitude values   y = runif(5, min = -90, max = 90)     # Random latitude values )  ## convert to sf sf_points <- st_as_sf(random_points, coords = c(\"x\", \"y\"), crs = 4326)  ## insert data into the database ddbs_write_vector(conn, sf_points, \"points\")  ## read data back into R ddbs_read_vector(conn, \"points\", crs = 4326)  ## disconnect from db dbDisconnect(conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"methods use dplyr's extension mechanism (dplyr_reconstruct) properly preserve spatial metadata operations. Executes accumulated query stores result DuckDB temporary table. result remains lazy (duckspatial_df) points materialized data, avoiding repeated computation complex query plans.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"","code":"# S3 method for class 'duckspatial_df' dplyr_reconstruct(data, template)  # S3 method for class 'duckspatial_df' left_join(   x,   y,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   ...,   keep = NULL,   na_matches = c(\"na\", \"never\"),   relationship = NULL )  # S3 method for class 'duckspatial_df' inner_join(   x,   y,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   ...,   keep = NULL,   na_matches = c(\"na\", \"never\"),   relationship = NULL )  # S3 method for class 'duckspatial_df' head(x, n = 6L, ...)  # S3 method for class 'duckspatial_df' glimpse(x, width = NULL, ...)  # S3 method for class 'duckspatial_df' compute(x, name = NULL, temporary = TRUE, ...)"},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"x duckspatial_df object ... Additional arguments passed dplyr::compute() name Optional name result table. NULL, unique temporary name generated. temporary TRUE (default), creates temporary table automatically cleaned connection closes.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"new duckspatial_df pointing materialized table, spatial metadata (CRS, geometry column) preserved.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"useful want : Cache intermediate results reuse across multiple subsequent operations Simplify complex query plans heavy operations like spatial joins Force execution specific point without pulling data R memory","code":""},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_dplyr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr methods for duckspatial_df — duckspatial_df_dplyr","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr)  # Complex pipeline - compute() caches intermediate result result <- countries |>   filter(POP_EST > 50000000) |>   ddbs_filter(argentina, predicate = \"touches\") |>   compute() |>  # Execute and cache here   select(NAME_ENGL, POP_EST) |>   ddbs_join(rivers, join = \"intersects\")  # Check query plan - should reference the cached table show_query(result) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"sf methods for duckspatial_df — duckspatial_df_sf","title":"sf methods for duckspatial_df — duckspatial_df_sf","text":"methods provide sf compatibility duckspatial_df objects, allowing work sf functions like st_crs(), st_geometry(), etc.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/duckspatial_df_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sf methods for duckspatial_df — duckspatial_df_sf","text":"","code":"# S3 method for class 'duckspatial_df' st_crs(x, ...)  # S3 method for class 'duckspatial_df' st_geometry(obj, ...)  # S3 method for class 'duckspatial_df' st_bbox(obj, ...)  # S3 method for class 'duckspatial_df' st_as_sf(x, ...)  # S3 method for class 'duckspatial_df' print(x, ..., n = 10)"},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Feedback for query success — feedback_query","title":"Feedback for query success — feedback_query","text":"Feedback query success","code":""},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feedback for query success — feedback_query","text":"","code":"feedback_query(quiet)"},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feedback for query success — feedback_query","text":"quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feedback for query success — feedback_query","text":"cli message","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_conn_from_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Get DuckDB connection from an object — get_conn_from_input","title":"Get DuckDB connection from an object — get_conn_from_input","text":"Extracts connection duckspatial_df, tbl_lazy, validates direct connection.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_conn_from_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get DuckDB connection from an object — get_conn_from_input","text":"","code":"get_conn_from_input(x)"},{"path":"https://cidree.github.io/duckspatial/reference/get_conn_from_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get DuckDB connection from an object — get_conn_from_input","text":"x duckspatial_df, tbl_lazy, duckdb_connection, NULL","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_conn_from_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get DuckDB connection from an object — get_conn_from_input","text":"duckdb_connection NULL","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Get column names in a DuckDB database — get_geom_name","title":"Get column names in a DuckDB database — get_geom_name","text":"Get column names DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get column names in a DuckDB database — get_geom_name","text":"","code":"get_geom_name(conn, x, rest = FALSE, collapse = FALSE, table_id = NULL)"},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get column names in a DuckDB database — get_geom_name","text":"conn DBIConnection object DuckDB database x name table rest whether return geometry column name, rest columns","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get column names in a DuckDB database — get_geom_name","text":"name geometry column table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Get names for the query — get_query_name","title":"Get names for the query — get_query_name","text":"Get names query","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get names for the query — get_query_name","text":"","code":"get_query_name(name)"},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get names for the query — get_query_name","text":"name table name","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get names for the query — get_query_name","text":"list fixed names","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets predicate name — get_st_predicate","title":"Gets predicate name — get_st_predicate","text":"Gets full predicate name shorter version","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets predicate name — get_st_predicate","text":"","code":"get_st_predicate(predicate)"},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets predicate name — get_st_predicate","text":"predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets predicate name — get_st_predicate","text":"character","code":""},{"path":"https://cidree.github.io/duckspatial/reference/import_view_to_connection.html","id":null,"dir":"Reference","previous_headings":"","what":"Import a view/table from one connection to another — import_view_to_connection","title":"Import a view/table from one connection to another — import_view_to_connection","text":"Enables cross-connection operations importing views using one three strategies.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/import_view_to_connection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import a view/table from one connection to another — import_view_to_connection","text":"","code":"import_view_to_connection(   target_conn,   source_conn,   source_object,   target_name = NULL )"},{"path":"https://cidree.github.io/duckspatial/reference/import_view_to_connection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import a view/table from one connection to another — import_view_to_connection","text":"target_conn Target DuckDB connection source_conn Source DuckDB connection source_object duckspatial_df, tbl_lazy, tbl_duckdb_connection source_conn target_name Name view target connection (auto-generated NULL)","code":""},{"path":"https://cidree.github.io/duckspatial/reference/import_view_to_connection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import a view/table from one connection to another — import_view_to_connection","text":"List imported view name cleanup function","code":""},{"path":"https://cidree.github.io/duckspatial/reference/is_duckspatial_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is a duckspatial_df — is_duckspatial_df","title":"Check if object is a duckspatial_df — is_duckspatial_df","text":"Check object duckspatial_df","code":""},{"path":"https://cidree.github.io/duckspatial/reference/is_duckspatial_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is a duckspatial_df — is_duckspatial_df","text":"","code":"is_duckspatial_df(x)"},{"path":"https://cidree.github.io/duckspatial/reference/is_duckspatial_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is a duckspatial_df — is_duckspatial_df","text":"x Object test","code":""},{"path":"https://cidree.github.io/duckspatial/reference/is_duckspatial_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is a duckspatial_df — is_duckspatial_df","text":"Logical","code":""},{"path":"https://cidree.github.io/duckspatial/reference/new_duckspatial_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a duckspatial lazy spatial data frame — new_duckspatial_df","title":"Create a duckspatial lazy spatial data frame — new_duckspatial_df","text":"Extends tbl_duckdb_connection spatial metadata (CRS, geometry column).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/new_duckspatial_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a duckspatial lazy spatial data frame — new_duckspatial_df","text":"","code":"new_duckspatial_df(x, crs = NULL, geom_col = \"geom\", source_table = NULL)"},{"path":"https://cidree.github.io/duckspatial/reference/new_duckspatial_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a duckspatial lazy spatial data frame — new_duckspatial_df","text":"x Input: tbl_duckdb_connection, tbl_lazy, similar dbplyr object crs CRS object string geom_col Name geometry column (default: \"geom\") source_table Name source table applicable","code":""},{"path":"https://cidree.github.io/duckspatial/reference/new_duckspatial_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a duckspatial lazy spatial data frame — new_duckspatial_df","text":"duckspatial_df object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Feedback for overwrite argument — overwrite_table","title":"Feedback for overwrite argument — overwrite_table","text":"Feedback overwrite argument","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feedback for overwrite argument — overwrite_table","text":"","code":"overwrite_table(x, conn, quiet, overwrite)"},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feedback for overwrite argument — overwrite_table","text":"x table name conn DBIConnection object DuckDB database quiet logical value. TRUE, suppresses informational messages. Defaults FALSE. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feedback for overwrite argument — overwrite_table","text":"cli message","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"major-changes-development-version","dir":"Changelog","previous_headings":"","what":"MAJOR CHANGES","title":"duckspatial (development version)","text":"duckspatial_df becomes main class duckspatial. represents lazy, table-like object whose data loaded memory explicitly materialized (ddbs_collect() st_as_sf()). Every function now accepts class input, ’s returned class default. user interested returning different class, ’s convenient output argument (#55, #63). ddbs_union(): spplited two new functions depending desired behavior: ddbs_union() ddbs_union_agg() (#77). ddbs_length, ddbs_area ddbs_distance: now use default best DuckDB function (e.g. ST_Area ST_Area_Spheroid) depending input’s CRS. Additionally, return units object (#80, #82).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"duckspatial (development version)","text":"ddbs_as_spatial(): converts table coordinates spatial object (#75). ddbs_geometry_type(): returns geometry type object (#76). ddbs_as_geojson(): converts geometry geojson format (#84).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"minor-changes-development-version","dir":"Changelog","previous_headings":"","what":"MINOR CHANGES","title":"duckspatial (development version)","text":"ddbs_buffer(): now four new arguments: num_triangles, cap_style, join_style, mitre_limit (#72). ddbs_quadkey(): can aggregate field output polygon tilexy (#78).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"duckspatial (development version)","text":"ddbs_length, ddbs_area ddbs_distance calculating wrong measure CRS geographic (#82).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"duckspatial-090","dir":"Changelog","previous_headings":"","what":"duckspatial 0.9.0","title":"duckspatial 0.9.0","text":"CRAN release: 2026-01-10 Learn version .","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"major-changes-0-9-0","dir":"Changelog","previous_headings":"","what":"MAJOR CHANGES","title":"duckspatial 0.9.0","text":"conn argument defaults now NULL. parameter mandatory anymore spatial operations, handled internally. argument moved x, y, function-mandatory arguments (#9). ddbs_write_vector() allows create temporary view argument temp = TRUE, much faster creating table (#14). ddbs_read_vector() uses internal optimizations geoarrow making much faster (#15). spatial functions allow now either sf DuckDB table input (x) /output (name = NULL name != NULL) (#19). crs crs_column arguments deprecated removed duckspatial v1.0.0. change aligns planned native CRS support DuckDB, scheduled v1.5.0 (expected February 2025) (#7).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"duckspatial 0.9.0","text":"Affine functions: ddbs_rotate(), ddbs_rotate_3d(), ddbs_shift(), ddbs_flip(), ddbs_scale(), ddbs_shear() (#37). ddbs_boundary(): returns boundary geometries (#17). ddbs_concave_hull(): new function create concave hull enclosing geometry (#23). ddbs_convex_hull(): new function create convex hull enclosing geometry (#23). ddbs_create_conn(): new convenient function create DuckDB connection spatial extension installed loaded. ddbs_drivers(): get list GDAL drivers file formats supported DuckDB spatial extension. ddbs_join(): new function perform spatial join operations (#6). ddbs_length(): adds new column length geometries (#17). ddbs_area(): adds new column area geometries (#17). ddbs_distance(): calculates distance two geometries (#34). ddbs_is_valid(): adds new logical column asserting simplicity geometries (#17). ddbs_is_valid(): adds new logical column asserting validity geometries (#17). ddbs_make_valid(): makes geometries valid (#17). ddbs_simplify(): makes geometries simple (#17). ddbs_bbox(): calculates bounding box (#25). ddbs_envelope(): returns envelope geometries (#36). ddbs_union(): union geometries (#36). ddbs_combine(): combines geometries multi-geometry (#36). ddbs_quadkey(): calculates quadkey tiles point geometries (#52). ddbs_exterior_ring(): returns exterior ring (shell) polygon geometry (#45). ddbs_make_polygon(): create POLYGON LINESTRING shell (#46). ddbs_predicate(): spatial predicates two geometries (#28). ddbs_intersects(), ddbs_crosses(), ddbs_touches(), …: shortcuts e.g.: ddbs_predicate(predicate = \"intersects\") (#28). ddbs_transform(): transforms one coordinates reference system another (#43). ddbs_as_text(): converts geometries well-known text (WKT) format (#47). ddbs_as_wkb(): converts geometries well-known binary (WKB) format (#48). ddbs_generate_points(): generates random points within bounding box x (#54). Spatial predicates: spatial predicates included function called ddbs_predicate(), user can specify spatial predicate. Another option, ’s use spatial predicate function, ddbs_intersects(), ddbs_crosses(), ddbs_touches(), etc.","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"minor-changes-0-9-0","dir":"Changelog","previous_headings":"","what":"MINOR CHANGES","title":"duckspatial 0.9.0","text":"functions now parameter quiet allows users suppress messages (#3). Spatial operations now don’t fail column dot (#33). Added vignettes (#42). ddbs_filter(): uses intersects ST_Intersects instead intersection. ddbs_filter(): doesn’t return duplicated observations geometry fulfills spatial predicate one geometries y (#50).","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"duckspatial-020","dir":"Changelog","previous_headings":"","what":"duckspatial 0.2.0","title":"duckspatial 0.2.0","text":"CRAN release: 2025-04-29","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"duckspatial 0.2.0","text":"ddbs_read_vector(): gains new argument clauses modify query table (e.g. “…”, “ORDER …”)","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-functions-0-2-0","dir":"Changelog","previous_headings":"","what":"NEW FUNCTIONS","title":"duckspatial 0.2.0","text":"ddbs_list_tables(): lists table schemas tables inside database ddbs_glimpse(): check first rows table ddbs_buffer(): calculates buffer around input geometry ddbs_centroid(): calculates centroid input geometry ddbs_difference(): calculates geometric difference two objects","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"IMPROVEMENTS","title":"duckspatial 0.2.0","text":"ddbs_intersection(): overwrite argument defaults FALSE instead NULL Better schemas management. Added support functions.","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"duckspatial-010","dir":"Changelog","previous_headings":"","what":"duckspatial 0.1.0","title":"duckspatial 0.1.0","text":"CRAN release: 2025-04-19 Initial CRAN submission.","code":""}]
