% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ddbs_predicates.R
\name{ddbs_intersects_extent}
\alias{ddbs_intersects_extent}
\title{Spatial intersects extent predicate}
\usage{
ddbs_intersects_extent(
  x,
  y,
  conn = NULL,
  conn_x = NULL,
  conn_y = NULL,
  id_x = NULL,
  id_y = NULL,
  sparse = TRUE,
  quiet = FALSE
)
}
\arguments{
\item{x}{Input spatial data. Can be:
\itemize{
\item A \code{duckspatial_df} object (lazy spatial data frame via dbplyr)
\item An \code{sf} object
\item A \code{tbl_lazy} from dbplyr
\item A character string naming a table/view in \code{conn}
}
Data is returned from this object.}

\item{y}{An \code{sf} spatial object. Alternatively, it can be a string with the
name of a table with geometry column within the DuckDB database \code{conn}.}

\item{conn}{A connection object to a DuckDB database. If \code{NULL}, the function
runs on a temporary DuckDB database.}

\item{conn_x}{A \code{DBIConnection} object to a DuckDB database for the input \code{x}.
If \code{NULL} (default), it is resolved from \code{conn} or extracted from \code{x}.}

\item{conn_y}{A \code{DBIConnection} object to a DuckDB database for the input \code{y}.
If \code{NULL} (default), it is resolved from \code{conn} or extracted from \code{y}.}

\item{id_x}{Character; optional name of the column in \code{x} whose values will
be used to name the list elements. If \code{NULL}, integer row numbers of \code{x} are used.}

\item{id_y}{Character; optional name of the column in \code{y} whose values will
replace the integer indices returned in each element of the list.}

\item{sparse}{A logical value. If \code{TRUE}, it returns a sparse index list. If \code{FALSE},
it returns a dense logical matrix.}

\item{quiet}{A logical value. If \code{TRUE}, suppresses any informational messages.
Defaults to \code{FALSE}.}
}
\value{
A list where each element contains indices (or IDs) of geometries in \code{y} whose
bounding box intersects the bounding box of the corresponding geometry in \code{x}.
See \code{\link[=ddbs_predicate]{ddbs_predicate()}} for details.
}
\description{
Tests if the bounding box of geometries in \code{x} intersect the bounding box of
geometries in \code{y}. Returns \code{TRUE} if the extents (bounding boxes) overlap.
This is faster than full geometry intersection but less precise.
}
\details{
This is a convenience wrapper around \code{\link[=ddbs_predicate]{ddbs_predicate()}} with
\code{predicate = "intersects_extent"}.
}
\examples{
\dontrun{
## load packages
library(dplyr)
library(duckspatial)
library(sf)

## read countries data, and rivers
countries_sf <- read_sf(system.file("spatial/countries.geojson", package = "duckspatial")) |>
  filter(CNTR_ID \%in\% c("PT", "ES", "FR", "IT"))
rivers_sf <- st_read(system.file("spatial/rivers.geojson", package = "duckspatial")) |>
  st_transform(st_crs(countries_sf))

# Fast bounding box intersection check
ddbs_intersects_extent(countries_sf, rivers_sf, id_x = "NAME_ENGL")
}
}
\seealso{
\code{\link[=ddbs_predicate]{ddbs_predicate()}} for other spatial predicates.
}
