% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ddbs_predicates.R
\name{ddbs_intersects}
\alias{ddbs_intersects}
\title{Spatial intersection predicate (ST_Intersects)}
\usage{
ddbs_intersects(x, y, conn = NULL, id_x = NULL, id_y = NULL, quiet = FALSE)
}
\arguments{
\item{x}{An \code{sf} spatial object. Alternatively, it can be a string with the
name of a table with geometry column within the DuckDB database \code{conn}.
Data is returned from this object.}

\item{y}{An \code{sf} spatial object. Alternatively, it can be a string with the
name of a table with geometry column within the DuckDB database \code{conn}.
Data is returned from this object.}

\item{conn}{A connection object to a DuckDB database. If \code{NULL}, the function
runs on a temporary DuckDB database.}

\item{id_x}{Character; optional name of the column in \code{x} whose values will
be used to name the list elements. If \code{NULL}, integer row numbers of \code{x} are used.}

\item{id_y}{Character; optional name of the column in \code{y} whose values will
replace the integer indices returned in each element of the list.}

\item{quiet}{A logical value. If \code{TRUE}, suppresses any informational messages.
Defaults to \code{FALSE}.}
}
\value{
A \strong{list} of length equal to the number of rows in \code{x}.
\itemize{
\item Each element contains:
\itemize{
\item \strong{integer vector} of row indices of \code{y} that intersect the corresponding
geometry of \code{x}, or
\item \strong{character vector} if \code{id_y} is supplied.
}
\item The names of the list elements:
\itemize{
\item are integer row numbers of \code{x}, or
\item the values of \code{id_x} if provided.
}
}
}
\description{
Computes spatial intersections between two geometry datasets using DuckDB's
spatial extension. Returns a list where each element corresponds to a row of
\code{x}, containing the indices (or IDs) of rows in \code{y} that intersect it.
}
\details{
#' This function mirrors the behavior of \code{\link[sf:geos_binary_pred]{sf::st_intersects()}}:
it performs a pairwise comparison between all geometries in \code{x} and \code{y}.

If \code{x} or \code{y} are not DuckDB tables, they are automatically copied into a
temporary in-memory DuckDB database (unless a connection is supplied via \code{conn}).

\code{id_x} or \code{id_y} may be used to replace the default integer indices with the
values of an identifier column in \code{x} or \code{y}, respectively.
}
\examples{
## Load packages
library(duckdb)
library(duckspatial)
library(dplyr)
library(sf)

## create in-memory DuckDB database
conn <- ddbs_create_conn(dbdir = "memory")

## read countries data, and rivers of Spain
countries_sf <- read_sf(system.file("spatial/countries.geojson", package = "duckspatial")) |> 
  filter(CNTR_ID \%in\% c("PT", "ES", "FR", "IT"))
rivers_sf <- st_read(system.file("spatial/rivers.geojson", package = "duckspatial")) |> 
  st_transform(st_crs(countries_sf))

## Store in DuckDB
ddbs_write_vector(conn, countries_sf, "countries")
ddbs_write_vector(conn, rivers_sf, "rivers")

## Option 1: Basic intersection (returns list of indices)
ddbs_intersects(countries_sf, rivers_sf, conn)

## Option 2: add ID column
ddbs_intersects(countries_sf, rivers_sf, conn, "NAME_ENGL", "RIVER_NAME")

## Option 3: use table names inside duckdb
ddbs_intersects("countries", "rivers", conn, "NAME_ENGL")
}
