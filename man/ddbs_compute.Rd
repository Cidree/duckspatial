% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/duckspatial_df_sf_methods.R
\name{ddbs_compute}
\alias{ddbs_compute}
\title{Force computation of a lazy duckspatial_df}
\usage{
ddbs_compute(x, ..., name = NULL, temporary = TRUE)
}
\arguments{
\item{x}{A \code{duckspatial_df} object}

\item{...}{Additional arguments passed to \code{dplyr::compute}}

\item{name}{Optional name for the result table. If NULL, a unique temporary
name is generated.}

\item{temporary}{If TRUE (default), creates a temporary table that is
automatically cleaned up when the connection closes.}
}
\value{
A new \code{duckspatial_df} pointing to the materialized table
}
\description{
Executes the accumulated query and stores the result in a DuckDB temporary
table. The result remains lazy (a \code{duckspatial_df}) but points to the
materialized data, avoiding repeated computation of complex query plans.
}
\details{
This is useful when you want to:
\itemize{
\item Cache intermediate results for reuse across multiple subsequent operations
\item Simplify complex query plans before heavy operations like spatial joins
\item Force execution at a specific point without pulling data into R memory
}
}
\examples{
\dontrun{
library(duckspatial)
library(dplyr)

# Load lazy spatial data
countries <- ddbs_open_dataset(
  system.file("spatial/countries.geojson", package = "duckspatial")
)

# Complex pipeline - ddbs_compute() caches intermediate result
cached <- countries |>
  filter(CNTR_ID \%in\% c("DE", "FR", "IT")) |>
  ddbs_compute()  # Execute and store in temp table

# Check query plan - should reference temp table
show_query(cached)

# Further operations continue from cached result
result <- cached |>
  ddbs_filter(other_layer, predicate = "intersects") |>
  st_as_sf()
}
}
