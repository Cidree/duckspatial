% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/duckspatial_df_dplyr_methods.R
\name{duckspatial_df_dplyr}
\alias{duckspatial_df_dplyr}
\alias{dplyr_reconstruct.duckspatial_df}
\alias{left_join.duckspatial_df}
\alias{inner_join.duckspatial_df}
\alias{head.duckspatial_df}
\alias{compute.duckspatial_df}
\title{dplyr methods for duckspatial_df}
\usage{
\method{dplyr_reconstruct}{duckspatial_df}(data, template)

\method{left_join}{duckspatial_df}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  relationship = NULL
)

\method{inner_join}{duckspatial_df}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  relationship = NULL
)

\method{head}{duckspatial_df}(x, n = 6L, ...)

\method{compute}{duckspatial_df}(x, name = NULL, temporary = TRUE, ...)
}
\arguments{
\item{x}{A \code{duckspatial_df} object}

\item{...}{Additional arguments passed to \code{\link[dplyr:compute]{dplyr::compute()}}}

\item{name}{Optional name for the result table. If NULL, a unique temporary
name is generated.}

\item{temporary}{If TRUE (default), creates a temporary table that is
automatically cleaned up when the connection closes.}
}
\value{
A new \code{duckspatial_df} pointing to the materialized table, with
spatial metadata (CRS, geometry column) preserved.
}
\description{
These methods use dplyr's extension mechanism (dplyr_reconstruct) to
properly preserve spatial metadata through operations.

Executes the accumulated query and stores the result in a DuckDB temporary
table. The result remains lazy (a \code{duckspatial_df}) but points to the
materialized data, avoiding repeated computation of complex query plans.
}
\details{
This is useful when you want to:
\itemize{
\item Cache intermediate results for reuse across multiple subsequent operations
\item Simplify complex query plans before heavy operations like spatial joins
\item Force execution at a specific point without pulling data into R memory
}
}
\examples{
\dontrun{
library(dplyr)

# Complex pipeline - compute() caches intermediate result
result <- countries |>
  filter(POP_EST > 50000000) |>
  ddbs_filter(argentina, predicate = "touches") |>
  compute() |>  # Execute and cache here
  select(NAME_ENGL, POP_EST) |>
  ddbs_join(rivers, join = "intersects")

# Check query plan - should reference the cached table
show_query(result)
}
}
\keyword{internal}
